/******************************************************************************
*
* Copyright (C) 2016 Hisilicon Technologies Co., Ltd.  All rights reserved.
*
* This program is confidential and proprietary to Hisilicon  Technologies Co., Ltd. (Hisilicon),
*  and may not be copied, reproduced, modified, disclosed to others, published or used, in
* whole or in part, without the express prior written permission of Hisilicon.
*
*****************************************************************************

  File Name    : pq_hal_hdr.c
  Version       : Initial Draft
  Author        : sdk
                      sdk
  Created      : 2016/06/15
  Description  :

******************************************************************************/
#include <linux/string.h>

#include "hi_type.h"
#include "hi_math.h"

#include "pq_hal_comm.h"
#include "drv_pq_ext.h"
#include "pq_hal_hdr.h"

#define HDR_MIN(x, y) (((x) > (y)) ? (y) : (x))
#define HDR_MAX(x, y) (((x) > (y)) ? (x) : (y))
#define HDR_CLIP3(low,high,x)  (HDR_MAX(HDR_MIN((high),(x)),(low)))

static const HI_S32 g_au32SinTable[61] =
{
    -500, -485, -469, -454, -438, -422, -407, -391,
    -374, -358, -342, -325, -309, -292, -276, -259,
    -242, -225, -208, -191, -174, -156, -139, -122,
    -104,  -87,  -70,  -52,  -35,  -17,    0,   17,
    35,     52,   70,   87,  104,  122,  139,  156,
    174,   191,  208,  225,  242,  259,  276,  292,
    309,   325,  342,  358,  374,  391,  407,  422,
    438,   454,  469,  485,  500
};

static const HI_U32 g_au32CosTable[61] =
{
    866, 875, 883, 891, 899,  906,  914,  921,
    927, 934, 940, 946, 951,  956,  961,  966,
    970, 974, 978, 982, 985,  988,  990,  993,
    995, 996, 998, 999, 999, 1000, 1000, 1000,
    999, 999, 998, 996, 995,  993,  990,  988,
    985, 982, 978, 974, 970,  966,  961,  956,
    951, 946, 940, 934, 927,  921,  914,  906,
    899, 891, 883, 875, 866
};


HI_S32 HiPP_HDR_HDR10toSDRTMApi(HI_PQ_HDR_CFG *pstPqHdrCfg, DM_INFO_S *pstDminfo);
HI_S32 HiPP_HDR_CalcXPos(HI_U32 *pTM_xlut , HI_PQ_HDR_CFG *pstPqHdrCfg);

static HI_PQ_HDR_CFG *pg_stPqHdrCfg     = HI_NULL;
static PQ_HDR_TM_COEF_S sg_stHdrTmapUsePara;
static PQ_PARAM_S *sg_pstHalHdrPqParam  = HI_NULL;
static HI_U32 sg_u32HdrParamSource = 0; //0代表来自PQbin;1 代表来自SDK
static HI_PQ_HDR_MODE_E sg_enHDRMode    = HI_PQ_HDR_MODE_HDR10_TO_SDR;

static DM_INFO_S stDminfo = {0};

static HI_U32 sg_u32HdrTmMode = 0;//选择HDR参数模式。0:固定参数，1:软算法参数，2.工具调试参数
static HI_U32 sg_u32HdrSmMode = 0;//选择HDR参数模式。0:固定参数，1:软算法参数，2.工具调试参数

static HI_U32 sg_u32TMScaleCoef = 7;

static HI_U32 sg_u32SrcAvgLum = 150000;
static HI_U32 sg_u32TargMinLum = 1000;
static HI_U32 sg_u32TargAvgLum = 2000000;
static HI_U32 sg_u32TargMaxLum = 3000000;
static HI_U32 sg_u32Contrast = 320;
static HI_U32 sg_u32HdrLwAvg = 300;
static HI_U32 sg_u32UhdMaxLumDefault = 15000000;
static HI_U32 sg_u32FhdMaxLumDefault = 15000000;

static HI_U32 sg_u32SrcMinPQ = 0;
static HI_U32 sg_u32SrcMaxPQ = 0;

HI_S16 g_aDstCSCTable[3][3];
HI_S16 g_as16DcOutR2Y[3] = { 64,  512,  512 };

HI_S16 g_aDstHdrOffsetCSCTable[3][3];
HI_S16 g_as16HdrOffsetDcOutR2Y[3] = { 64,  512,  512 };


static HI_U32 g_u32TMLutXStep[8] =        /* U5.0  [0,20] */
{
    4,  6,  8,  9,  10, 12, 14, 16
};

static HI_U32 g_u32TMLutXPos[8]  =        /* U20.0 [0,1048575] */
{
    64, 512,    1024,   3072,   8192,   65536,  327680, 1048575
};

static HI_U32 g_u32TMLutXNum[8]  =        /* U6.0  [0,63] */
{
    4,  11, 13, 17, 22, 36, 52, 63
};

static HI_U32 g_u32TMLutXNumP[8]  =        /* U6.0  [0,63] */
{
    4,  7, 2, 4, 5, 14, 16, 11
};

static HI_U32 g_u32TMLut_debug[64] =             /* U9.7 [0,65535] */
{
    23914,    23914,    22658,    21587,    20660,    17904,    16054,    14705,
    13667,    12838,    12157,    11585,    9977 ,    8965 ,    7732 ,    6987 ,
    6476 ,    6099 ,    5567 ,    5199 ,    4922 ,    4701 ,    4518 ,    3990 ,
    3628 ,    3345 ,    3110 ,    2908 ,    2731 ,    2573 ,    2430 ,    2301 ,
    2184 ,    2076 ,    1977 ,    1885 ,    1801 ,    1520 ,    1307 ,    1142 ,
    1010 ,    903  ,    815  ,    743  ,    681  ,    630  ,    585  ,    546  ,
    512  ,    482  ,    455  ,    431  ,    410  ,    341  ,    293  ,    256  ,
    228  ,    205  ,    186  ,    171  ,    158  ,    146  ,    137  ,    128
};

static HI_U32 g_u32SMLutXStep[PQ_SMAP_SEG_SIZE] =        /* U5.0  [0,21] */
{
    5,  7,  9,  10,  11, 13, 15, 17
};

static HI_U32 g_u32SMLutXPos[PQ_SMAP_SEG_SIZE]  =        /* U21.0 [0,1048575] */
{
    128, 1024,    2048,   6144,   16384,   131072,  655360, 2097151
};

static HI_U32 g_u32SMLutXNum[PQ_SMAP_SEG_SIZE]  =        /* U6.0  [0,63] */
{
    4,  11, 13, 17, 22, 36, 52, 63
};

static HI_U32 g_u32SMLutXNumP[PQ_SMAP_SEG_SIZE]  =        /* U6.0  [0,63] */
{
    4,  11, 13, 17, 22, 36, 52, 63
};

static HI_U32 g_u32SMLut_debug[64] =                  //U2.8 [0,1023]
{
    256,    256,    256,    256,    256,    256,    256,    256,
    256,    256,    256,    256,    256,    256,    256,    256,
    256,    256,    256,    256,    256,    256,    256,    256,
    256,    256,    256,    256,    256,    256,    256,    256,
    256,    256,    256,    256,    256,    256,    256,    256,
    256,    256,    256,    256,    256,    256,    256,    256,
    256,    256,    256,    256,    256,    256,    256,    256,
    256,    256,    256,    256,    256,    256,    256,    256
};

/* ------------------Y2R:YUV2RGB---------------------------- */

/* YUV to RGB params: 10bit in, 10bit out */
static const HI_U16 u16ScaleY2R   = 13;    /*U4.0  [0,15] */
static const HI_U16 u16ClipMinY2R = 0;     /* U10.0  [0,1023] */
static const HI_U16 u16ClipMaxY2R = 1023;  /* U10.0  [0,1023] */
static const HI_U16 u16ClipMaxY2R_1000 = 770;

static const HI_S16 as16DcInY2R_L[3] =       /* S10.0  [-1024, 1023] */
{
    -64,
    -512,
    -512
};

static const HI_S16 as16DcInY2R_F[3] =
{
    0,
    0,
    0
};

static const HI_S16 as16M33Y2R_601L[3][3] =
{
    {9567 , 0      ,  13113} ,
    {9567 , -3219 ,  -6679},
    {9567 , 16557 ,  0    }
};

static const HI_S16 as16M33Y2R_601F[3][3] =
{
    {8192 ,  0      ,   11485} ,
    {8192 ,  -2819  ,  -5850 },
    {8192 , 14501  ,    0   }
};

static const HI_S16 as16M33Y2R_709L[3][3] =
{
    {9567,           0,       14729},
    {9567,       -1752,       -4379},
    {9567,       17356,           0}
};

static const HI_S16 as16M33Y2R_709F[3][3] =
{
    {8192,           0 ,      12901},
    {8192,       -1535 ,      -3835},
    {8192 ,       15201 ,          0}
};

static const HI_S16 as16M33Y2R_2020L[3][3] =
{
    {9567,           0 ,      13792},
    {9567,       -1539 ,      -5344},
    {9567 ,       17597,           0}
};

static const HI_S16 as16M33Y2R_2020F[3][3] =
{
    {8192,           0 ,      12080},
    {8192 ,      -1348  ,     -4681},
    {8192 ,      15412 ,          0}
};

static const HI_S16 as16DcOutY2R[3] =      /*  S10.0 [-1024, 1023] */
{
    0,
    0,
    0
};

/* ------------------ToneMapping---------------------------- */

/* ToneMapping Tmap Params: 20bit in, 20bit out */
static const HI_U16 u16ScaleLumaCal       = 15;                   /* U4.0  [0,15] */
static const HI_U16 au16M3LumaCal_2020[3] = {8608, 22217, 1943};  /* U1.15 [0, 65535]     {0.2627, 0.6780, 0.0593}<<u16ScaleLumaCal */
static const HI_U16 au16M3LumaCal_709[3]  = {6970, 23432, 2366};  /* U1.15 [0, 65535]      */
static const HI_U16 au16M3LumaCal_601[3]  = {9798, 19235, 3736};  // U1.15 [0, 65535]

static const HI_U16 u16ScaleCoefTM       = 8;                    /*  U4.0  [0,15] */
static const HI_U32 u32ClipMinTM         = 0;                    /*  U20.0  [0,1048575] */
static const HI_U32 u32ClipMaxTM         = 1048575;              /*  U20.0  [0,1048575] */

static const HI_U32 au32TMapStep[PQ_TMAP_SEG_SIZE] =        /* U5.0  [0,20] */
{
    4,  6,  8,  9,  10, 12, 14, 16
};

static const HI_U32 au32TMapPos[PQ_TMAP_SEG_SIZE]  =        /* U20.0 [0,1048575] */
{
    64, 512,    1024,   3072,   8192,   65536,  327680, 1048575
};

static const HI_U32 au32TMapNum[PQ_TMAP_SEG_SIZE]  =        /* U6.0  [0,63] */
{
    4,  11, 13, 17, 22, 36, 52, 63
};

/* ToneMapping Lut: HDR10  to SDR */
static const HI_U16 u16ScaleCoefTM_HDR10toSDR = 8;//7;         /* U4.0  [0,15] */
static const HI_U32 au32TMLut_HDR10toSDR[64] =             /* U9.7 [0,65535] */
{
    0,
    5000,
    7000,
    9000,
    10568,
    10091,
    9768 ,
    9531 ,
    9348 ,
    9200 ,
    9078 ,
    8974 ,
    8675 ,
    8478 ,
    8220 ,
    8045 ,
    7912 ,
    7801 ,
    7619 ,
    7467 ,
    7332 ,
    7209 ,
    7093 ,
    6680 ,
    6317 ,
    5988 ,
    5686 ,
    5407 ,
    5149 ,
    4909 ,
    4685 ,
    4477 ,
    4282 ,
    4099 ,
    3929 ,
    3769 ,
    3619 ,
    3104 ,
    2698 ,
    2560 ,
    2560 ,
    2560 ,
    2560 ,
    2560 ,
    2560 ,
    2560 ,
    2560 ,
    2560 ,
    2560 ,
    2560 ,
    2560 ,
    2560 ,
    2560 ,
    2560 ,
    2560 ,
    2560 ,
    2560 ,
    2560 ,
    2560 ,
    2560 ,
    2560 ,
    2560 ,
    2560 ,
    2560
};

/*************** ToneMapping Lut Params:  *******************************/
static HI_U32 au32TMLut_HDR10toSDR_Vivid[64] =             /* U9.7 [0,65535] */
{
    0,
    5000,
    7000,
    9000,
    10568,
    10091,
    9768 ,
    9531 ,
    9348 ,
    9200 ,
    9078 ,
    8974 ,
    8675 ,
    8478 ,
    8220 ,
    8045 ,
    7912 ,
    7801 ,
    7619 ,
    7467 ,
    7332 ,
    7209 ,
    7093 ,
    6680 ,
    6317 ,
    5988 ,
    5686 ,
    5407 ,
    5149 ,
    4909 ,
    4685 ,
    4477 ,
    4282 ,
    4099 ,
    3929 ,
    3769 ,
    3619 ,
    3104 ,
    2698 ,
    2560 ,
    2560 ,
    2560 ,
    2560 ,
    2560 ,
    2560 ,
    2560 ,
    2560 ,
    2560 ,
    2560 ,
    2560 ,
    2560 ,
    2560 ,
    2560 ,
    2560 ,
    2560 ,
    2560 ,
    2560 ,
    2560 ,
    2560 ,
    2560 ,
    2560 ,
    2560 ,
    2560 ,
    2560
};

static HI_U32 au32TMLut_HDR10toSDR_b100[64] =             /* U9.7 [0,65535] */
{
    0, 5000, 7000, 9000, 10568, 10091, 9768, 9657, 9657, 9657, 9657, 9657, 9657, 9657, 9657, 9657,
    9657, 9657, 9657, 9657, 9657, 9657, 9657, 9357, 8943, 8226, 7590, 7024, 6519, 6067, 5662, 5298,
    4971, 4675, 4407, 4164, 3943, 3233, 2724, 2560, 2560, 2560, 2560, 2560, 2560, 2560, 2560, 2560,
    2560, 2560, 2560, 2560, 2560, 2560, 2560, 2560, 2560, 2560, 2560, 2560, 2560, 2560, 2560, 2560
};

static HI_U32 au32TMLut_HDR10toSDR_b0[64] =             /* U9.7 [0,65535] */
{
    0, 5000, 7000, 9000, 10568, 10091, 9768, 9531, 9517, 9002, 8580, 8225, 7229, 6604, 5846, 5391,
    5081, 4855, 4539, 4325, 4167, 4043, 3942, 3662, 3476, 3334, 3215, 3111, 3018, 2933, 2854, 2780,
    2710, 2643, 2580, 2519, 2461, 2251, 2070, 1910, 1770, 1645, 1534, 1434, 1345, 1280, 1280, 1280,
    1280, 1280, 1280, 1280, 1280, 1280, 1280, 1280, 1280, 1280, 1280, 1280, 1280, 1280, 1280, 1280
};

static HI_U32 au32TMLut_HDR10toSDR_d100[64] =             /* U9.7 [0,65535] */
{
    11000, 15000, 19516, 23217, 25185, 18878, 16199, 14444, 13223, 12243, 11450, 10884, 9903, 9370, 8568, 8065,
    7912, 7801, 7619, 7467, 7332, 7209, 7093, 6680, 6317, 5988, 5686, 5407, 5149, 4909, 4685, 4477 ,
    4282, 4099, 3929, 3769, 3619, 3104, 2698, 2560, 2560, 2560, 2560, 2560, 2560, 2560, 2560, 2560 ,
    2560, 2560, 2560, 2560, 2560, 2560, 2560, 2560, 2560, 2560, 2560, 2560, 2560, 2560, 2560, 2560
};

static HI_U32 au32TMLut_HDR10toSDR_d0[64] =             /* U9.7 [0,65535] */
{

    0, 500, 877, 1350, 1839, 2607, 3220, 3740, 4142, 4422, 4638, 4828, 5662, 6292, 6641, 6803,
    6960, 7115, 7363, 7452, 7332, 7209, 7093, 6680, 6317, 5988, 5686, 5407, 5149, 4909, 4685, 4477,
    4282, 4099, 3929, 3769, 3619, 3104, 2698, 2560, 2560, 2560, 2560, 2560, 2560, 2560, 2560, 2560,
    2560, 2560, 2560, 2560, 2560, 2560, 2560, 2560, 2560, 2560, 2560, 2560, 2560, 2560, 2560, 2560
};

static HI_U32 au32TMLut_HDR10toSDR_BP[64] =             /* U9.7 [0,65535] */
{
    0,
    4000,
    6000,
    8000,
    9075,
    8366,
    7891,
    7543,
    7276,
    7062,
    6886,
    6738,
    6321,
    6057,
    5732,
    5532,
    5393,
    5287,
    5133,
    5021,
    4933,
    4859,
    4794,
    4589,
    4426,
    4285,
    4156,
    4036,
    3924,
    3817,
    3716,
    3619,
    3526,
    3437,
    3352,
    3270,
    3191,
    2902,
    2651,
    2560,
    2560,
    2560,
    2560,
    2560,
    2560,
    2560,
    2560,
    2560,
    2560,
    2560,
    2560,
    2560,
    2560,
    2560,
    2560,
    2560,
    2560,
    2560,
    2560,
    2560,
    2560,
    2560,
    2560,
    2560
};

static HI_U32 au32TMLut_HDR10toSDR_DP[64] =             /* U9.7 [0,65535] */
{
    0,
    15700,
    30904,
    34617,
    33503,
    30186,
    27952,
    26319,
    25058,
    24048,
    23215,
    22513,
    20516,
    19236,
    17622,
    16596,
    15854,
    15274,
    14387,
    13706,
    13143,
    12656,
    12223,
    10815,
    9715 ,
    8804 ,
    8028 ,
    7360 ,
    6778 ,
    6267 ,
    5816 ,
    5417 ,
    5062 ,
    4745 ,
    4460 ,
    4204 ,
    3973 ,
    3241 ,
    2725 ,
    2560 ,
    2560 ,
    2560 ,
    2560 ,
    2560 ,
    2560 ,
    2560 ,
    2560 ,
    2560 ,
    2560 ,
    2560 ,
    2560 ,
    2560 ,
    2560 ,
    2560 ,
    2560 ,
    2560 ,
    2560 ,
    2560 ,
    2560 ,
    2560 ,
    2560 ,
    2560 ,
    2560 ,
    2560
};

/* ToneMapping Lut: SDR to HDR10 */
static const HI_U16 u16ScaleCoefTM_SDRtoHDR1000 = 15;         /* U4.0  [0,15] */
static const HI_U32 au32TMLut_SDRtoHDR1000[64] =                   //U1.15 [0,65535]
{
    10820,
    10820,
    5410 ,
    3743 ,
    4522 ,
    6551 ,
    6799 ,
    6947 ,
    6926 ,
    6905 ,
    6889 ,
    6853 ,
    6774 ,
    6714 ,
    6604 ,
    6510 ,
    6474 ,
    6434 ,
    6354 ,
    6285 ,
    6236 ,
    6201 ,
    6175 ,
    6092 ,
    6070 ,
    6040 ,
    6019 ,
    6024 ,
    6030 ,
    6038 ,
    6047 ,
    6056 ,
    6064 ,
    6093 ,
    6105 ,
    6131 ,
    6159 ,
    6248 ,
    6370 ,
    6475 ,
    6600 ,
    6745 ,
    6877 ,
    7033 ,
    7176 ,
    7338 ,
    7508 ,
    7668 ,
    7855 ,
    8037 ,
    8212 ,
    8418 ,
    8610 ,
    9475 ,
    10474,
    11620,
    12945,
    14521,
    16321,
    18500,
    21081,
    24253,
    28346,
    32733
};


/* ToneMapping Lut: HDR10 to BBC */
static const HI_U16 u16ScaleCoefTM_HDR10toHLG = 10;        /* U4.0  [0,15] */
static const HI_U32 au32TMLut_HDR10toHLG[64] =              /*U6.10 [0,65535] */
{
    46552,
    46552,
    40832,
    37818,
    35815,
    31414,
    29095,
    27554,
    26416,
    25520,
    24787,
    24169,
    22385,
    21199,
    19634,
    18594,
    17826,
    17222,
    16310,
    15636,
    15106,
    14672,
    14306,
    13250,
    12548,
    12029,
    11622,
    11288,
    11006,
    10764,
    10551,
    10363,
    10194,
    10041,
    9901 ,
    9772 ,
    9654 ,
    9255 ,
    8941 ,
    8684 ,
    8192 ,
    7282 ,
    6554 ,
    5958 ,
    5461 ,
    5041 ,
    4681 ,
    4369 ,
    4096 ,
    3855 ,
    3641 ,
    3449 ,
    3277 ,
    2731 ,
    2341 ,
    2048 ,
    1820 ,
    1638 ,
    1489 ,
    1365 ,
    1260 ,
    1170 ,
    1092 ,
    1024
};

/* ToneMapping Lut: BBC to HDR10 */
static const HI_U16 u16ScaleCoefTM_HLGtoHDR10 = 15;           /* U4.0  [0,15] */
static const HI_U32 au32TMLut_HLGtoHDR10[64] =                /*U1.15 [0,65535] */
{
    /*PQ1250*/
    2853 ,
    2853 ,
    3277 ,
    3554 ,
    3764 ,
    4324 ,
    4689 ,
    4967 ,
    5193 ,
    5386 ,
    5555 ,
    5705 ,
    6187 ,
    6554 ,
    7107 ,
    7528 ,
    7872 ,
    8164 ,
    8648 ,
    9042 ,
    9378 ,
    9672 ,
    9933 ,
    10773,
    11411,
    11931,
    12374,
    12762,
    13107,
    13420,
    13705,
    13969,
    14214,
    14444,
    14659,
    14863,
    15056,
    15743,
    16328,
    16839,
    17295,
    17707,
    18084,
    18432,
    18756,
    19059,
    19343,
    19612,
    19867,
    20109,
    20340,
    20562,
    20774,
    21545,
    22220,
    22821,
    23365,
    23863,
    24322,
    24749,
    25148,
    25524,
    25878,
    26214
};

// ToneMapping Lut:  SDR to HLG
static const HI_U16 u16ScaleCoefTM_SDR2HLG = 12 ;
static const HI_U32 au32TMLut_SDR2HLG[64] =                    //U9.7 [0,65535]
{
    10339 ,     10339 ,     10339 ,      5169 ,      3554 ,      4814 ,      4702 ,      4549 ,
    4354 ,      4208 ,      4105 ,      3991 ,      3685 ,      3488 ,      3207 ,      3021 ,
    2895 ,      2794 ,      2634 ,      2515 ,      2424 ,      2351 ,      2291 ,      2118 ,
    2012 ,      1931 ,      1867 ,      1821 ,      1783 ,      1750 ,      1721 ,      1696 ,
    1674 ,      1658 ,      1640 ,      1627 ,      1616 ,      1576 ,      1553 ,      1535 ,
    1525 ,      1523 ,      1521 ,      1525 ,      1529 ,      1537 ,      1547 ,      1556 ,
    1571 ,      1585 ,      1599 ,      1617 ,      1634 ,      1717 ,      1819 ,      1940 ,
    2081 ,      2250 ,      2441 ,      2671 ,      2939 ,      3262 ,      3672 ,      4096 ,
};

// ToneMapping Lut:  HDR10 to HLG
static const HI_U16 u16ScaleCoefTM_HDR102HLG = 8 ;
static const HI_U32 au32TMLut_HDR102HLG[64] =                  //U9.7 [0,65535]
{
    11074 ,     11074 ,      9866 ,      9221 ,      8790 ,      7831 ,      7319 ,      6976 ,
    6722 ,      6521 ,      6355 ,      6215 ,      5809 ,      5537 ,      5175 ,      4933 ,
    4753 ,      4611 ,      4395 ,      4234 ,      4108 ,      4004 ,      3915 ,      3660 ,
    3488 ,      3361 ,      3260 ,      3178 ,      3108 ,      3047 ,      2994 ,      2947 ,
    2905 ,      2866 ,      2831 ,      2799 ,      2769 ,      2668 ,      2588 ,      2341 ,
    2048 ,      1820 ,      1638 ,      1489 ,      1365 ,      1260 ,      1170 ,      1092 ,
    1024 ,       964 ,       910 ,       862 ,       819 ,       683 ,       585 ,       512 ,
    455 ,       410 ,       372 ,       341 ,       315 ,       293 ,       273 ,       256 ,
};


// ToneMapping Lut:  HLG2SDR
static const HI_U16 u16ScaleCoefTM_HLG2SDR = 12 ;
static const HI_U32 au32TMLut_HLG2SDR[64] =                    //U9.7 [0,65535]
{
    1982 ,      1982 ,      2276 ,      2467 ,      2613 ,      2995 ,      3242 ,      3427 ,
    3575 ,      3700 ,      3807 ,      3901 ,      4191 ,      4398 ,      4684 ,      4879 ,
    5023 ,      5135 ,      5304 ,      5429 ,      5528 ,      5611 ,      5683 ,      5907 ,
    6078 ,      6220 ,      6341 ,      6449 ,      6544 ,      6630 ,      6708 ,      6778 ,
    6843 ,      6902 ,      6956 ,      7006 ,      7052 ,      7202 ,      7310 ,      7385 ,
    7435 ,      7464 ,      7476 ,      7474 ,      7460 ,      7437 ,      7404 ,      7364 ,
    7318 ,      7266 ,      7210 ,      7150 ,      7086 ,      6807 ,      6505 ,      6195 ,
    5888 ,      5589 ,      5302 ,      5029 ,      4772 ,      4531 ,      4306 ,      4096 ,
};


/* ToneMapping Lut: AVS to HDR10 */
static const HI_U16 u16ScaleCoefTM_Linear = 8;             /* U4.0  [0,15] */
static const HI_U32 au32TMLut_Linear[64] =                 /* U8.8 [0,65535] */
{
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256,
    256
};


/* ------------------GamutMapping---------------------------- */
/* GamutMapping Params: 20bit in, 20bit out  */
static const HI_U16 u16ScaleGMap   = 14;                        /*  U4.0  [0,15] */
static const HI_U32 u32ClipMinGMap = 0;                         /*   U20.0 [0,1048575] */
static const HI_U32 u32ClipMaxGMap = 1048575;                   /*   U20.0 [0,1048575] */

static const HI_S16 as16M33GMap_2020to709[3][3] =               /*  S1.14 [-2^15, 2^15-1] = [-32768, 32767] */
{
    //BT2020 to BT709
    {27209 ,      -9632  ,     -1194 },
    { -2045 ,      18565  ,      -138 },
    { -297  ,     -1648   ,    18330  }
};

static const HI_S16 as16M33GMap_709to2020[3][3] =               /*   S1.14 [-2^15, 2^15-1] = [-32768, 32767]  */
{
    //BT709 to BT2020
    {10279 ,       5396  ,       710},
    {1134  ,     15064   ,      187 },
    {268   ,     1442    ,   14673  }
};

static const HI_S16 as16M33GMap_linear[3][3] =                  /*  S1.14 [-2^15, 2^15-1] = [-32768, 32767] */
{
    /* Linear */
    { 16384,       0  ,       0 },
    {     0,     16384,       0 },
    {     0,       0  ,   16384 }
};


static const HI_S16 as16M33GMAP_Pal_601_709[3][3] =
{
    //BT601 to BT709
    {17106  ,      -724      ,    -1 },
    { -2   ,    16386    ,       0 },
    { 1    ,    193     ,  16191  }
};

static const HI_S16 as16M33GMAP_Ntsc_601_709[3][3] =
{
    //BT601ntsc to BT709
    { 15394  ,       820     ,    167 },
    {  290   ,    15826    ,     269},
    {  -26   ,      -72   ,    16483  }
};

static const HI_S16 as16M33GMAP_Pal_601_2020[3][3] =
{
    //BT601 to BT2020
    { 10731 ,       4951   ,      701 },
    { 1182  ,     15018   ,      184 },
    {  280   ,     1603   ,   14500  }
};

static const HI_S16 as16M33GMAP_Ntsc_601_2020[3][3] =
{
    //BT601ntsc to BT2020
    {  9752    ,    5723   ,      908 },
    { 1331    ,   14606    ,     447 },
    {  254    ,    1342    ,   14788  }
};


/* ---------------------------------------------- */

/************* DeGamma Params **************/
static const HI_U32 au32DeGmm_step[PQ_DEGMM_SEG_SIZE] =
{
    3, 4, 5, 6
};          /*U4.0  [0,15] */

static const HI_U32 au32DeGmm_pos[PQ_DEGMM_SEG_SIZE]  =
{
    208, 640, 896, 1023
};/*U10.0 [0,1023] */

static const HI_U32 au32DeGmm_num[PQ_DEGMM_SEG_SIZE]  =
{
    26, 27, 8, 2
};        /*U6.0  [0,63] */

/************* DeGamma Params **************/
static const HI_U32 au32DeGmm_sdr2hdr_step[PQ_DEGMM_SEG_SIZE] =
{
    3, 4, 5, 6
};          /*U4.0  [0,15] */

static const HI_U32 au32DeGmm_sdr2hdr_pos[PQ_DEGMM_SEG_SIZE]  =
{
    208, 640, 896, 1023
};/*U10.0 [0,1023] */

static const HI_U32 au32DeGmm_sdr2hdr_num[PQ_DEGMM_SEG_SIZE]  =
{
    26, 27, 8, 2
};        /*U6.0  [0,63] */


/* DePQ curve: HDR10 */
static const HI_U32 au32DeGmmLut_PQ[64] =                            //U20.0 [0,1048575]
{
    0 ,         0 ,         1 ,         1 ,         2 ,         4 ,         5 ,         8 ,        11 ,        14 ,        18 ,        23 ,        29 ,        35 ,        43 ,        52 ,
    62 ,        74 ,        87 ,       102 ,       118 ,       137 ,       158 ,       181 ,       207 ,       236 ,       268 ,       342 ,       432 ,       540 ,       671 ,       826 ,
    1012 ,      1231 ,      1491 ,      1796 ,      2155 ,      2576 ,      3068 ,      3643 ,      4312 ,      5091 ,      5997 ,      7047 ,      8264 ,      9673 ,     11302 ,     13186 ,
    15362 ,     17873 ,     20770 ,     24111 ,     27962 ,     32399 ,     43403 ,     58004 ,     77382 ,    103115 ,    137324 ,    182875 ,    243651 ,    324943 ,    580813 ,   1048575 ,
};


/* DeHLG Curve: BBC HDR */
static const HI_U32 au32DeGmmLut_HLG[64] =                               //U20.0 [0,1048575]
{
    0 ,        21 ,        85 ,       192 ,       341 ,       533 ,       768 ,      1045 ,      1365 ,      1728 ,      2133 ,      2581 ,      3072 ,      3605 ,      4181 ,      4800 ,
    5461 ,      6165 ,      6912 ,      7701 ,      8533 ,      9408 ,     10325 ,     11285 ,     12288 ,     13333 ,     14421 ,     16725 ,     19200 ,     21845 ,     24661 ,     27648 ,
    30805 ,     34133 ,     37632 ,     41301 ,     45141 ,     49152 ,     53333 ,     57685 ,     62208 ,     66901 ,     71765 ,     76800 ,     82005 ,     87381 ,     93088 ,     99316 ,
    106113 ,    113530 ,    121625 ,    130458 ,    140098 ,    150619 ,    174628 ,    203223 ,    237277 ,    277833 ,    326133 ,    383656 ,    452163 ,    533750 ,    746633 ,   1048575
};

// DeGamma Curve: SDR
static const HI_U32 au32DeGmmLut_24[64] =                            //U20.0 [0,1048575]
{
    0 ,         9 ,        49 ,       128 ,       256 ,       437 ,       677 ,       981 ,      1351 ,      1793 ,      2308 ,      2902 ,      3575 ,      4333 ,      5176 ,      6108 ,
    7132 ,      8248 ,      9461 ,     10772 ,     12183 ,     13697 ,     15315 ,     17039 ,     18871 ,     20814 ,     22868 ,     27320 ,     32239 ,     37641 ,     43536 ,     49937 ,
    56856 ,     64304 ,     72293 ,     80832 ,     89932 ,     99603 ,    109856 ,    120699 ,    132142 ,    144194 ,    156864 ,    170160 ,    184092 ,    198668 ,    213895 ,    229783 ,
    246338 ,    263569 ,    281483 ,    300088 ,    319391 ,    339400 ,    381563 ,    426633 ,    474664 ,    525710 ,    579823 ,    637053 ,    697449 ,    761060 ,    898112 ,   1048575
};

static const HI_U32 au32DeGmmLut_22[64] =                            //U20.0 [0,1048575]
{
    0 ,        24 ,       111 ,       272 ,       512 ,       837 ,      1249 ,      1754 ,      2353 ,      3048 ,      3844 ,      4740 ,      5740 ,      6846 ,      8058 ,      9379 ,
    10809 ,     12352 ,     14007 ,     15776 ,     17661 ,     19662 ,     21780 ,     24018 ,     26376 ,     28854 ,     31454 ,     37024 ,     43093 ,     49667 ,     56753 ,     64358 ,
    72487 ,     81146 ,     90341 ,    100077 ,    110358 ,    121190 ,    132578 ,    144526 ,    157038 ,    170118 ,    183772 ,    198002 ,    212814 ,    228209 ,    244194 ,    260770 ,
    277941 ,    295712 ,    314085 ,    333064 ,    352651 ,    372851 ,    415099 ,    459832 ,    507073 ,    556845 ,    609169 ,    664065 ,    721556 ,    781659 ,    909780 ,   1048575 ,

};

static const HI_U32 au32DeGmmLut_BT709[64] =                             //U20.0 [0,1048575]
{
    0 ,      1820 ,      3641 ,      5461 ,      7282 ,      9102 ,     10923 ,     12743 ,     14564 ,     16384 ,     18204 ,     19983 ,     21907 ,     23930 ,     26051 ,     28271 ,
    30591 ,     33013 ,     35537 ,     38163 ,     40892 ,     43726 ,     46664 ,     49707 ,     52857 ,     56114 ,     59478 ,     66530 ,     74019 ,     81950 ,     90327 ,     99155 ,
    108437 ,    118178 ,    128382 ,    139053 ,    150193 ,    161808 ,    173901 ,    186474 ,    199532 ,    213077 ,    227114 ,    241644 ,    256671 ,    272199 ,    288230 ,    304766 ,
    321811 ,    339368 ,    357439 ,    376027 ,    395135 ,    414764 ,    455600 ,    498555 ,    543647 ,    590895 ,    640318 ,    691933 ,    745756 ,    801805 ,    920645 ,   1048575
};

/******************* Gmm-8 Lut Params *************************/
static const HI_U32 au32GmmStep[PQ_GMM_SEG_SIZE] =        /* U5.0  [0,31] */
{
    4,  6,  8,  9,  10, 12, 14, 16
};

static const HI_U32 au32GmmPos[PQ_GMM_SEG_SIZE]  =        /* U20.0 [0,1048575] */
{
    64, 512,  1024, 3072,   8192,   65536,  327680, 1048575
};

static const HI_U32 au32GmmNum[PQ_GMM_SEG_SIZE]  =        /* U6.0  [0,63] */
{
    4,  11, 13, 17, 22, 36, 52, 63
};

// PQ Curve
static const HI_U32 au32GmmLut_PQ10000[64] =              //U12.0 [0,4095]
{
    0 ,       304 ,       400 ,       466 ,       517 ,       657 ,       749 ,       820 ,       878 ,       927 ,       970 ,      1008 ,      1129 ,      1220 ,      1354 ,      1454 ,
    1533 ,      1600 ,      1708 ,      1794 ,      1865 ,      1926 ,      1980 ,      2146 ,      2267 ,      2361 ,      2440 ,      2506 ,      2564 ,      2616 ,      2662 ,      2704 ,
    2742 ,      2777 ,      2810 ,      2841 ,      2869 ,      2969 ,      3050 ,      3119 ,      3178 ,      3231 ,      3278 ,      3321 ,      3360 ,      3395 ,      3428 ,      3459 ,
    3488 ,      3515 ,      3540 ,      3564 ,      3587 ,      3668 ,      3736 ,      3794 ,      3846 ,      3892 ,      3933 ,      3971 ,      4006 ,      4038 ,      4067 ,      4095 ,
} ;

static const HI_U32 au32GmmLut_PQ4000[64] =              //U12.0 [0,4095]
{
    0 ,       206 ,       278 ,       327 ,       367 ,       477 ,       551 ,       609 ,       657 ,       697 ,       733 ,       765 ,       867 ,       945 ,      1061 ,      1149 ,
    1220 ,      1279 ,      1376 ,      1454 ,      1519 ,      1575 ,      1624 ,      1778 ,      1891 ,      1980 ,      2054 ,      2118 ,      2173 ,      2222 ,      2267 ,      2307 ,
    2344 ,      2378 ,      2410 ,      2440 ,      2467 ,      2564 ,      2644 ,      2712 ,      2771 ,      2823 ,      2869 ,      2912 ,      2950 ,      2986 ,      3019 ,      3050 ,
    3079 ,      3106 ,      3131 ,      3155 ,      3178 ,      3260 ,      3329 ,      3388 ,      3441 ,      3488 ,      3530 ,      3569 ,      3604 ,      3637 ,      3668 ,      3696 ,
} ;

static const HI_U32 au32GmmLut_PQ2000[64] =              //U12.0 [0,4095]
{
    0 ,       151 ,       206 ,       246 ,       278 ,       367 ,       429 ,       477 ,       517 ,       551 ,       582 ,       609 ,       697 ,       765 ,       867 ,       945 ,
    1008 ,      1061 ,      1149 ,      1220 ,      1279 ,      1331 ,      1376 ,      1519 ,      1624 ,      1708 ,      1778 ,      1838 ,      1891 ,      1938 ,      1980 ,      2019 ,
    2054 ,      2087 ,      2118 ,      2146 ,      2173 ,      2267 ,      2344 ,      2410 ,      2467 ,      2518 ,      2564 ,      2606 ,      2644 ,      2679 ,      2712 ,      2742 ,
    2771 ,      2797 ,      2823 ,      2847 ,      2869 ,      2950 ,      3019 ,      3079 ,      3131 ,      3178 ,      3221 ,      3260 ,      3296 ,      3329 ,      3360 ,      3388 ,
} ;

static const HI_U32 au32GmmLut_PQ1250[64] =              //U12.0 [0,4095]
{
    0 ,       121 ,       167 ,       201 ,       227 ,       304 ,       358 ,       400 ,       435 ,       466 ,       493 ,       517 ,       596 ,       657 ,       749 ,       820 ,
    878 ,       927 ,      1008 ,      1074 ,      1129 ,      1177 ,      1220 ,      1354 ,      1454 ,      1533 ,      1600 ,      1657 ,      1708 ,      1753 ,      1794 ,      1831 ,
    1865 ,      1897 ,      1926 ,      1954 ,      1980 ,      2071 ,      2146 ,      2210 ,      2267 ,      2317 ,      2361 ,      2402 ,      2440 ,      2474 ,      2506 ,      2536 ,
    2564 ,      2591 ,      2616 ,      2639 ,      2662 ,      2742 ,      2810 ,      2869 ,      2922 ,      2969 ,      3011 ,      3050 ,      3086 ,      3119 ,      3150 ,      3178 ,
} ;

static const HI_U32 au32GmmLut_PQ1200[64] =              //U12.0 [0,4095]
{
    0 ,       118 ,       164 ,       197 ,       223 ,       299 ,       352 ,       394 ,       429 ,       459 ,       485 ,       509 ,       587 ,       648 ,       740 ,       810 ,
    867 ,       916 ,       996 ,      1061 ,      1116 ,      1164 ,      1207 ,      1340 ,      1439 ,      1519 ,      1585 ,      1642 ,      1692 ,      1737 ,      1778 ,      1815 ,
    1849 ,      1881 ,      1910 ,      1938 ,      1964 ,      2054 ,      2129 ,      2193 ,      2249 ,      2299 ,      2344 ,      2385 ,      2422 ,      2457 ,      2489 ,      2518 ,
    2547 ,      2573 ,      2598 ,      2622 ,      2644 ,      2724 ,      2792 ,      2851 ,      2904 ,      2950 ,      2993 ,      3032 ,      3067 ,      3101 ,      3131 ,      3160 ,
} ;

static const HI_U32 au32GmmLut_PQ1000[64] =              //U12.0 [0,4095]
{
    0 ,       108 ,       151 ,       181 ,       206 ,       278 ,       327 ,       367 ,       400 ,       429 ,       454 ,       477 ,       551 ,       609 ,       697 ,       765 ,
    820 ,       867 ,       945 ,      1008 ,      1061 ,      1108 ,      1149 ,      1279 ,      1376 ,      1454 ,      1519 ,      1575 ,      1624 ,      1668 ,      1708 ,      1744 ,
    1778 ,      1809 ,      1838 ,      1865 ,      1891 ,      1980 ,      2054 ,      2118 ,      2173 ,      2222 ,      2267 ,      2307 ,      2344 ,      2378 ,      2410 ,      2440 ,
    2467 ,      2494 ,      2518 ,      2542 ,      2564 ,      2644 ,      2712 ,      2771 ,      2823 ,      2869 ,      2912 ,      2950 ,      2986 ,      3019 ,      3050 ,      3079 ,
} ;

//HLG Curve
static const HI_U32 au32GmmLut_HLG[64] =              //U12.0 [0,4095]
{
    0 ,        28 ,        39 ,        48 ,        55 ,        78 ,        96 ,       111 ,       124 ,       136 ,       147 ,       157 ,       192 ,       222 ,       271 ,       313 ,
    350 ,       384 ,       443 ,       496 ,       543 ,       586 ,       627 ,       768 ,       887 ,       991 ,      1086 ,      1173 ,      1254 ,      1330 ,      1402 ,      1470 ,
    1536 ,      1598 ,      1659 ,      1717 ,      1773 ,      1982 ,      2165 ,      2313 ,      2436 ,      2541 ,      2633 ,      2714 ,      2788 ,      2854 ,      2916 ,      2972 ,
    3024 ,      3073 ,      3119 ,      3162 ,      3203 ,      3346 ,      3466 ,      3569 ,      3660 ,      3740 ,      3812 ,      3878 ,      3939 ,      3995 ,      4047 ,      4095
};

// Gamma Curve
static const HI_U32 au32GmmLut_22[64] =              //U12.0 [0,4095]
{
    0 ,        26 ,        36 ,        44 ,        50 ,        68 ,        82 ,        93 ,       103 ,       112 ,       120 ,       128 ,       154 ,       175 ,       211 ,       240 ,
    266 ,       289 ,       329 ,       364 ,       396 ,       425 ,       451 ,       543 ,       618 ,       684 ,       744 ,       798 ,       847 ,       894 ,       938 ,       979 ,
    1019 ,      1057 ,      1093 ,      1128 ,      1161 ,      1285 ,      1396 ,      1498 ,      1591 ,      1679 ,      1761 ,      1839 ,      1913 ,      1984 ,      2052 ,      2118 ,
    2181 ,      2242 ,      2301 ,      2358 ,      2413 ,      2622 ,      2812 ,      2988 ,      3153 ,      3307 ,      3454 ,      3593 ,      3726 ,      3854 ,      3977 ,      4095
};

static const HI_U32 au32GmmLut_24[64] =              //U12.0 [0,4095]
{
    0 ,        40 ,        54 ,        64 ,        72 ,        96 ,       114 ,       128 ,       140 ,       152 ,       162 ,       171 ,       202 ,       228 ,       270 ,       304 ,
    334 ,       360 ,       406 ,       446 ,       481 ,       513 ,       542 ,       642 ,       724 ,       794 ,       857 ,       914 ,       966 ,      1015 ,      1060 ,      1103 ,
    1144 ,      1183 ,      1220 ,      1256 ,      1290 ,      1416 ,      1527 ,      1629 ,      1722 ,      1808 ,      1889 ,      1966 ,      2039 ,      2108 ,      2174 ,      2237 ,
    2298 ,      2357 ,      2414 ,      2469 ,      2522 ,      2721 ,      2902 ,      3068 ,      3222 ,      3367 ,      3503 ,      3632 ,      3756 ,      3873 ,      3986 ,      4095 ,
};

static const HI_U32 au32GmmLut_bt709[64] =              //U12.0 [0,4095]
{
    0 ,         0 ,         1 ,         1 ,         1 ,         2 ,         3 ,         4 ,         6 ,         7 ,         8 ,         9 ,        13 ,        18 ,        27 ,        36 ,
    45 ,        54 ,        72 ,        90 ,       108 ,       126 ,       144 ,       216 ,       288 ,       360 ,       426 ,       486 ,       541 ,       592 ,       641 ,       686 ,
    730 ,       772 ,       812 ,       850 ,       887 ,      1024 ,      1146 ,      1257 ,      1360 ,      1456 ,      1547 ,      1632 ,      1713 ,      1791 ,      1866 ,      1937 ,
    2006 ,      2073 ,      2138 ,      2200 ,      2261 ,      2489 ,      2697 ,      2889 ,      3068 ,      3237 ,      3397 ,      3549 ,      3694 ,      3833 ,      3966 ,      4095 ,
};

/* RGB to YUV Params */
/* --------------R2Y:RGB2YUV-------------------------------- */

static const HI_U16 u16ScaleR2Y      = 14;                      /* U4.0  [0,15] */
static const HI_U16 u16ClipMinRF2YL    = 64;                      /* U10.0  [0,1023] */
static const HI_U16 u16ClipMaxRF2YL    = 1023;                     /* U10.0  [0,1023] */
static const HI_U16 u16ClipMinRF2YF    = 0;                      /* U10.0  [0,1023] */
static const HI_U16 u16ClipMaxRF2YF    = 1023;                     /* U10.0  [0,1023] */

static const HI_S16 as16DcInRF2YL[3] =                            /* S10.0  [-1024, 1023] */
{
    0,
    0,
    0
};

static const  HI_S16 as16DcInRF2YF[3] =      // S10.0  [-1024, 1023]
{
    0,
    0,
    0
};

static HI_S16 as16M33RF2YL_709[3][3] =      // S1.14 [-32768, 32767]
{
    //BT709
    {2984  ,     10034   ,     1013  },
    { -1643 ,      -5531  ,      7175 },
    {7175  ,     -6518   ,     -659  }
};

static const HI_S16 as16M33RF2YL_2020NCL[3][3] =      // S1.14 [-32768, 32767]
{
    //BT2020
    {3685  ,      9512  ,       832  },
    { -2004 ,      -5171 ,       7175 },
    {7175  ,     -6598  ,      -577  }
};

static const HI_S16 as16M33RF2YL_601[3][3] =      // S1.14 [-32768, 32767]
{
    //BT601
    {4195    ,    8235   ,     1599  },
    { -2421 ,      -4754  ,      7175 },
    {7175   ,    -6004    ,   -1167  }
};

static HI_S16  as16M33RF2YF_709[3][3] =      // S1.14 [-32768, 32767]
{
    //BT709
    {3483    ,   11718     ,   1183  },
    { -1877  ,     -6315   ,     8192 },
    { 8192   ,    -7441    ,    -751  }
};

static const HI_S16  as16M33RF2YF_2020NCL[3][3] =      // S1.14 [-32768, 32767]
{
    //BT2020
    { 4304   ,    11108    ,     972  },
    { -2288   ,    -5904   ,     8192 },
    {8192     ,  -7533     ,   -659  }
};

static const HI_S16 as16M33RF2YF_601[3][3] =      // S1.14 [-32768, 32767]
{
    //BT601
    {4899    ,    9617     ,   1868 },
    { -2765   ,    -5427    ,    8192 },
    { 8192   ,    -6855    ,   -1332 }
};

static const HI_S16 as16DcOutRF2YL[3]  =       /* s10.0  [-1024,1023] */
{
    64,
    512,
    512
};

static const HI_S16 as16DcOutRF2YF[3] =
{
    0,
    512,
    512
};  // s10.0  [-1024,1023]

/* ------------------R2Y:RGB2RGB---------------------------- */
static const HI_U16  u16ScaleRF2RF   = 14;   // U4.0  [0,15]
static const HI_U16  u16ClipMinRF2RF = 0;    // U10.0  [0,1023]
static const HI_U16  u16ClipMaxRF2RF = 1023; // U10.0  [0,1023]

static const HI_S16   as16DcInRF2RF[3] =      // S10.0  [-1024, 1023]
{
    0,
    0,
    0
};

static const HI_S16   as16M33RF2RF[3][3] =      // S1.14 [-32768, 32767]
{
    {16384    ,   0     ,   0  },
    { 0  ,     16384   ,     0 },
    { 0   ,    0    ,    16384  }
};

static const HI_S16   as16DcOutRF2RF[3] =
{
    0,
    0,
    0
};  // s10.0  [-1024,1023]

static HI_PQ_ACC_HISTGRAM_S gs_stACCHistGram;
static HI_U32 g_au32TM_LUT[64] = {0};
static HI_U32 g_au32TM_PQTool[64] = {0};
static HI_U32 g_u32ACCOutWidth  = 3840;
static HI_U32 g_u32ACCOutHeight = 2160;
static HI_U32 g_u32HdrMode      = 0;
static HI_U32 g_u32ACCDarkStr   = 0;
static HI_U32 g_u32ACCBrightStr = 0;
static HI_U32 g_u32DarkCvStr    = 50;
static HI_U32 g_u32BrightCvStr  = 50;

static HI_U32 g_u32Bright   = 128;
static HI_U32 g_u32Contrast = 128;
static HI_U32 g_u32Satu     = 128;
static HI_U32 g_u32Hue      = 128;

static HI_U32 g_u32Red      = 128;
static HI_U32 g_u32Green    = 128;
static HI_U32 g_u32Blue     = 128;

static HI_U32 g_u32HdrOffsetBright   = 128;
static HI_U32 g_u32HdrOffsetContrast = 128;
static HI_U32 g_u32HdrOffsetSatu     = 128;
static HI_U32 g_u32HdrOffsetHue      = 128;
static HI_U32 g_u32HdrOffsetRed      = 128;
static HI_U32 g_u32HdrOffsetGreen    = 128;
static HI_U32 g_u32HdrOffsetBlue     = 128;

HI_S32 PQ_HAL_SetHDRTMCurve(HI_PQ_SETHDROFFSET_S *pstHdrOffsetPara)
{
    PQ_CHECK_NULL_PTR(pstHdrOffsetPara);

    g_u32HdrMode        = pstHdrOffsetPara->u32HdrMode;
    g_u32ACCDarkStr     = pstHdrOffsetPara->u32ACCdark;
    g_u32ACCBrightStr   = pstHdrOffsetPara->u32ACCbrigt;
    g_u32DarkCvStr      = pstHdrOffsetPara->u32darkCv;
    g_u32BrightCvStr    = pstHdrOffsetPara->u32brightCv;

    return HI_SUCCESS;
}

HI_S32 PQ_HAL_SetHdrCscSetting(HI_PQ_PICTURE_SETTING_S *pstPicSetting)
{
    PQ_CHECK_NULL_PTR(pstPicSetting);

    g_u32Bright   = (HI_U32)pstPicSetting->u16Brightness;
    g_u32Contrast = (HI_U32)pstPicSetting->u16Contrast;
    g_u32Satu     = (HI_U32)pstPicSetting->u16Hue;
    g_u32Hue      = (HI_U32)pstPicSetting->u16Saturation;

    return HI_SUCCESS;
}

HI_S32 PQ_HAL_SetHdrOffset(HI_PQ_SETHDROFFSET_S *pstHdrOffsetPara)
{
    PQ_CHECK_NULL_PTR(pstHdrOffsetPara);

    g_u32HdrOffsetBright   = pstHdrOffsetPara->u32Bright;
    g_u32HdrOffsetContrast = pstHdrOffsetPara->u32Contrast;
    g_u32HdrOffsetSatu     = pstHdrOffsetPara->u32Satu;
    g_u32HdrOffsetHue      = pstHdrOffsetPara->u32Hue;
    g_u32HdrOffsetRed      = pstHdrOffsetPara->u32R;
    g_u32HdrOffsetGreen    = pstHdrOffsetPara->u32G;
    g_u32HdrOffsetBlue     = pstHdrOffsetPara->u32B;

    return HI_SUCCESS;
}

HI_S32 PQ_HAL_GetHDRPqTm(HI_U32 u32TmType)
{
    HI_U32 i;

    if (0 == sg_u32HdrParamSource)
    {
        pqprint(PQ_PRN_HDR, "all 7 TM Curves are from SDK\n");
    }
    else
    {
        pqprint(PQ_PRN_HDR, "all 7 TM Curves are from PQbin\n");
    }

    switch (u32TmType)
    {
        case 0:
            pqprint(PQ_PRN_HDR, "nTM_ori\n");
            for (i = 0; i < 64; i++)
            {
                pqprint(PQ_PRN_HDR, "TmapUse = %d, vivid = %d \n", sg_stHdrTmapUsePara.au32TMLut[i], au32TMLut_HDR10toSDR_Vivid[i]);
            }
            break;
        case 1:
            pqprint(PQ_PRN_HDR, "nTM_bright_100\n");
            for (i = 0; i < 64; i++)
            {
                pqprint(PQ_PRN_HDR, "TmapUse b100 = %d, b100 = %d\n", sg_stHdrTmapUsePara.au32TM_B100[i], au32TMLut_HDR10toSDR_b100[i]);
            }
            break;
        case 2:
            pqprint(PQ_PRN_HDR, "nTM_bright_0\n");
            for (i = 0; i < 64; i++)
            {
                pqprint(PQ_PRN_HDR, "TmapUse b0 = %d, b0 = %d\n", sg_stHdrTmapUsePara.au32TM_B0[i], au32TMLut_HDR10toSDR_b0[i]);
            }
            break;
        case 3:
            pqprint(PQ_PRN_HDR, "nTM_dark_100\n");
            for (i = 0; i < 64; i++)
            {
                pqprint(PQ_PRN_HDR, "TmapUse d100 = %d, d100 = %d\n", sg_stHdrTmapUsePara.au32TM_D100[i], au32TMLut_HDR10toSDR_d100[i]);
            }
            break;
        case 4:
            pqprint(PQ_PRN_HDR, "nTM_dark_0\n");
            for (i = 0; i < 64; i++)
            {
                pqprint(PQ_PRN_HDR, "TmapUse d0 = %d, d0 = %d\n", sg_stHdrTmapUsePara.au32TM_D0[i], au32TMLut_HDR10toSDR_d0[i]);
            }
            break;
        case 5:
            pqprint(PQ_PRN_HDR, "nTM_bright_protect\n");
            for (i = 0; i < 64; i++)
            {
                pqprint(PQ_PRN_HDR, "TmapUse BP = %d, BP = %d\n", sg_stHdrTmapUsePara.au32TM_BP[i], au32TMLut_HDR10toSDR_BP[i]);
            }
            break;
        case 6:
            pqprint(PQ_PRN_HDR, "nTM_dark_protect\n");
            for (i = 0; i < 64; i++)
            {
                pqprint(PQ_PRN_HDR, "TmapUse DP = %d, DP = %d\n", sg_stHdrTmapUsePara.au32TM_DP[i], au32TMLut_HDR10toSDR_DP[i]);
            }
            break;
    }
    return HI_SUCCESS;
}

HI_S32 PQ_HAL_SetHDRACCHistGram(HI_U32 u32ACCOutWidth, HI_U32 u32ACCOutHeight, HI_PQ_ACC_HISTGRAM_S *pstACCHistGram)
{
    PQ_CHECK_NULL_PTR(pstACCHistGram);

    g_u32ACCOutWidth  = u32ACCOutWidth;
    g_u32ACCOutHeight = u32ACCOutHeight;

    memcpy(&gs_stACCHistGram, pstACCHistGram, sizeof(HI_PQ_ACC_HISTGRAM_S));

    return HI_SUCCESS;
}

HI_S32 HiHDR_DynTM(HI_PQ_ACC_HISTGRAM_S *pstACCHistGram, HI_U32 *TMLut, HI_U32 u32ACCOutWidth, HI_U32 u32ACCOutHeight)
{
    int i;// j;
    HI_S64 Tmp;
    HI_S64 TMLutTmp;
    HI_U32 u32Width  = u32ACCOutWidth;
    HI_U32 u32Height = u32ACCOutHeight;
    HI_U32 SumPixel  = (HI_U32)(u32Width * u32Height);
    HI_U32 Hist[8]   =  {0};  //ACC 8段直方图CV=[127,255,383,511,639,767,895,1023]  Lum=[0.15,3,22,103,419,1608,6215,10000] nits
    HI_U32 HistD3[3] = {0}; //ACC 三段动态直方图 CV=[0~P1, P0~P3, P2~1023]
    HI_U32 HistD5[5] = {0}; // 5段计算直方图，用于亮场景判别，CV=[0~P0, P0~P1, P1~P2, P2~P3, P3~1023]
    HI_U16 NormRange = 1000;
    HI_U16 HistNorm[8]      = {0};
    HI_U16 HistD5Norm[5]    = {0};
    HI_S16 LightLvlCoef[8]  = { -4, -2, -1, 0, 1, 2, 5, 1};
    HI_S32 LightLvlEst = 0;
    HI_U16 AlphaDarkGain   = g_u32ACCDarkStr * 1024 / 50;
    HI_U16 AlphaBrightGain = g_u32ACCBrightStr * 1024 / 50;
    HI_U16 AlphaGainScale  = 10;
    HI_U16 AlphaScale  = 15;
    HI_S32 AlphaDark   = 0;
    HI_S32 AlphaBright = 0;

    memcpy(HistD3,  pstACCHistGram->u32HistGram0, sizeof(HI_U32) * 3);
    memcpy(Hist,    pstACCHistGram->u32HistGram1, sizeof(HI_U32) * 8);

    HistD5[0] = Hist[0] + Hist[1] + Hist[2] + Hist[3] + Hist[4];    //CV = 0~P0;
    HistD5[1] = HistD3[0] - HistD5[0];                              //CV = P0~P1;
    HistD5[2] = SumPixel - HistD3[0] - HistD3[2];                   //CV = P1~P2;
    HistD5[3] = HistD3[1] - HistD5[1] - HistD5[2];                  //CV = P2~P3;
    HistD5[4] = HistD3[2] - HistD5[3];                              //CV = P3~1023;

    for (i = 0; i < 8; i++)
    {
        HistNorm[i] = (HI_U16)(div64_s64(((HI_U64)Hist[i] * NormRange), SumPixel));
    }

    for (i = 0; i < 5; i++)
    {
        HistD5Norm[i] = (HI_U16)(div64_s64(((HI_U64)HistD5[i] * NormRange), SumPixel));
    }

    LightLvlEst = 0;
    HistNorm[0] = HDR_MAX(HistNorm[0] - 256, 0); //预处理减黑边；

    for (i = 0; i < 8; i++)
    {
        LightLvlEst += LightLvlCoef[i] * HistNorm[i];
    }
    pqprint(PQ_PRN_HDR, "Hist:%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d\n",
            Hist[0], Hist[1], Hist[2], Hist[3], Hist[4], Hist[5], Hist[6], Hist[7], HistD3[0], HistD3[1], HistD3[2]);

    if (LightLvlEst <= -200)        //暗场景保护
    {
        pqprint(PQ_PRN_HDR, "LightLvlEstB:%d\n", LightLvlEst);
        if (LightLvlEst > -600)
        {
            AlphaDark = (HI_S32)(((abs(LightLvlEst) - 200) * 600 / (600 - 200) ) << AlphaScale) / 1500;
        }
        else
        {
            AlphaDark = (HI_S32)((abs(LightLvlEst)) << AlphaScale) / 1500;
        }
        pqprint(PQ_PRN_HDR, "AlphaD0:%d\n", AlphaDark);

        AlphaDark = HDR_CLIP3(0, (3 << AlphaScale) / 2, AlphaDark);
        pqprint(PQ_PRN_HDR, "AlphaD1:%d\n", AlphaDark);
        pqprint(PQ_PRN_HDR, "AlphaDarkGain:%d\n", AlphaDarkGain);
        AlphaDark = (HI_S32)(((HI_S64)AlphaDark * AlphaDarkGain) >> AlphaGainScale);
        Tmp = (1 << AlphaScale) - AlphaDark;
        pqprint(PQ_PRN_HDR, "Tmp,AlphaD:%d,%d\n", (HI_S32)Tmp, AlphaDark);

        for (i = 0; i < 64; i++)
        {
            TMLutTmp = ((HI_S64)Tmp * TMLut[i] + (HI_S64)AlphaDark * sg_stHdrTmapUsePara.au32TM_DP[i]) >> AlphaScale;
            TMLut[i] = (HI_U32)HDR_CLIP3(0, 65535, TMLutTmp);
        }
    }
    else if (LightLvlEst >= 100)
    {
        pqprint(PQ_PRN_HDR, "LightLvlEstB:%d\n", LightLvlEst);
        if (LightLvlEst < 300)
        {
            AlphaBright = (HI_S32)(((abs(LightLvlEst) - 100) * 300 / (300 - 100) ) << AlphaScale) / 500;
        }
        else
        {
            AlphaBright = (HI_S32)((abs(LightLvlEst)) << AlphaScale) / 500;
        }
        pqprint(PQ_PRN_HDR, "AlphaB0:%d\n", AlphaBright);
        AlphaBright = HDR_CLIP3(0, (3 << AlphaScale) / 2, AlphaBright);
        pqprint(PQ_PRN_HDR, "AlphaB1:%d\n", AlphaBright);
        pqprint(PQ_PRN_HDR, "AlphaBrightGain:%d\n", AlphaBrightGain);
        AlphaBright = (HI_S32)(((HI_S64)AlphaBright * AlphaBrightGain) >> AlphaGainScale);
        Tmp = (1 << AlphaScale) - AlphaBright;
        pqprint(PQ_PRN_HDR, "Tmp,AlphaB:%d,%d\n", (HI_S32)Tmp, AlphaBright);
        for (i = 0; i < 64; i++)
        {
            TMLutTmp = ((HI_S64)Tmp * TMLut[i] + (HI_S64)AlphaBright * sg_stHdrTmapUsePara.au32TM_BP[i]) >> AlphaScale;
            TMLut[i] = (HI_U32)HDR_CLIP3(0, 65535, TMLutTmp);
        }
    }
    else
    {
    }
    return HI_SUCCESS;
}

static HI_VOID PQ_hal_CalCSCCoefRGBtoYCbCr(HI_U32 Contrast, HI_U32 Saturation, HI_U32 Hue,
        HI_U32 Kr, HI_U32 Kg, HI_U32 Kb,
        HI_S16 pCSCTable[3][3], HI_S16 pDstCSCTable[3][3])
{
    HI_S32 ContrastAdjust;
    HI_S32 SaturationAdjust;
    HI_S32 rGain, gGain, bGain;

    ContrastAdjust   = Contrast   * 40 / 51;
    SaturationAdjust = Saturation * 40 / 51;
    Hue   = Hue * 60 / 255;
    rGain = Kr  * 40 / 51;
    gGain = Kg  * 40 / 51;
    bGain = Kb  * 40 / 51;

    g_aDstCSCTable[0][0] = (HI_S16)((HI_S32)pCSCTable[0][0] * ContrastAdjust * rGain  / 10000);
    g_aDstCSCTable[0][1] = (HI_S16)((HI_S32)pCSCTable[0][1] * ContrastAdjust * gGain  / 10000);
    g_aDstCSCTable[0][2] = (HI_S16)((HI_S32)pCSCTable[0][2] * ContrastAdjust * bGain  / 10000);
    g_aDstCSCTable[1][0]  = (HI_S16)(((HI_S32)(pCSCTable[1][0] * g_au32CosTable[Hue]) / 1000
                                      + (HI_S32)(pCSCTable[2][0] * g_au32SinTable[Hue]) / 1000)
                                     * SaturationAdjust * rGain / 10000);
    g_aDstCSCTable[1][1]  = (HI_S16)(((HI_S32)(pCSCTable[1][1] * g_au32CosTable[Hue]) / 1000
                                      + (HI_S32)(pCSCTable[2][1] * g_au32SinTable[Hue]) / 1000)
                                     * SaturationAdjust * gGain  / 10000);
    g_aDstCSCTable[1][2]  = (HI_S16)(((HI_S32)(pCSCTable[1][2] * g_au32CosTable[Hue]) / 1000
                                      + (HI_S32)(pCSCTable[2][2] * g_au32SinTable[Hue]) / 1000)
                                     * SaturationAdjust * bGain  / 10000);
    g_aDstCSCTable[2][0] = (HI_S16)(((HI_S32)(pCSCTable[2][0] * g_au32CosTable[Hue]) / 1000
                                     - (HI_S32)(pCSCTable[1][0] * g_au32SinTable[Hue]) / 1000)
                                    * SaturationAdjust * rGain  / 10000);
    g_aDstCSCTable[2][1] = (HI_S16)(((HI_S32)(pCSCTable[2][1] * g_au32CosTable[Hue]) / 1000
                                     - (HI_S32)(pCSCTable[1][1] * g_au32SinTable[Hue]) / 1000)
                                    * SaturationAdjust * gGain  / 10000);
    g_aDstCSCTable[2][2] = (HI_S16)(((HI_S32)(pCSCTable[2][2] * g_au32CosTable[Hue]) / 1000
                                     - (HI_S32)(pCSCTable[1][2] * g_au32SinTable[Hue]) / 1000)
                                    * SaturationAdjust * bGain  / 10000);
    return;
}

static HI_VOID PQ_hal_HdrOffsetCalCSCCoefRGBtoYCbCr(HI_U32 Contrast, HI_U32 Saturation, HI_U32 Hue,
        HI_U32 Kr, HI_U32 Kg, HI_U32 Kb,
        HI_S16 pCSCTable[3][3], HI_S16 pDstCSCTable[3][3])
{
    HI_S32 ContrastAdjust;
    HI_S32 SaturationAdjust;
    HI_S32 rGain, gGain, bGain;

    ContrastAdjust   = Contrast   * 40 / 51;
    SaturationAdjust = Saturation * 40 / 51;
    Hue   = Hue * 60 / 255;
    rGain = Kr  * 40 / 51;
    gGain = Kg  * 40 / 51;
    bGain = Kb  * 40 / 51;

    g_aDstHdrOffsetCSCTable[0][0] = (HI_S16)((HI_S32)pCSCTable[0][0] * ContrastAdjust * rGain  / 10000);
    g_aDstHdrOffsetCSCTable[0][1] = (HI_S16)((HI_S32)pCSCTable[0][1] * ContrastAdjust * gGain  / 10000);
    g_aDstHdrOffsetCSCTable[0][2] = (HI_S16)((HI_S32)pCSCTable[0][2] * ContrastAdjust * bGain  / 10000);
    g_aDstHdrOffsetCSCTable[1][0]  = (HI_S16)(((HI_S32)(pCSCTable[1][0] * g_au32CosTable[Hue]) / 1000
                                      + (HI_S32)(pCSCTable[2][0] * g_au32SinTable[Hue]) / 1000)
                                     * SaturationAdjust * rGain / 10000);
    g_aDstHdrOffsetCSCTable[1][1]  = (HI_S16)(((HI_S32)(pCSCTable[1][1] * g_au32CosTable[Hue]) / 1000
                                      + (HI_S32)(pCSCTable[2][1] * g_au32SinTable[Hue]) / 1000)
                                     * SaturationAdjust * gGain  / 10000);
    g_aDstHdrOffsetCSCTable[1][2]  = (HI_S16)(((HI_S32)(pCSCTable[1][2] * g_au32CosTable[Hue]) / 1000
                                      + (HI_S32)(pCSCTable[2][2] * g_au32SinTable[Hue]) / 1000)
                                     * SaturationAdjust * bGain  / 10000);
    g_aDstHdrOffsetCSCTable[2][0] = (HI_S16)(((HI_S32)(pCSCTable[2][0] * g_au32CosTable[Hue]) / 1000
                                     - (HI_S32)(pCSCTable[1][0] * g_au32SinTable[Hue]) / 1000)
                                    * SaturationAdjust * rGain  / 10000);
    g_aDstHdrOffsetCSCTable[2][1] = (HI_S16)(((HI_S32)(pCSCTable[2][1] * g_au32CosTable[Hue]) / 1000
                                     - (HI_S32)(pCSCTable[1][1] * g_au32SinTable[Hue]) / 1000)
                                    * SaturationAdjust * gGain  / 10000);
    g_aDstHdrOffsetCSCTable[2][2] = (HI_S16)(((HI_S32)(pCSCTable[2][2] * g_au32CosTable[Hue]) / 1000
                                     - (HI_S32)(pCSCTable[1][2] * g_au32SinTable[Hue]) / 1000)
                                    * SaturationAdjust * bGain  / 10000);
    return;
}


HI_S32 PQ_HAL_CalcHdrTmapACCHistGram(HI_PQ_HDR_CFG *pstPqHdrCfg)
{
    PQ_CHECK_NULL_PTR(pstPqHdrCfg);

    HiHDR_DynTM(&gs_stACCHistGram, pstPqHdrCfg->stTMAP.pu32LUTTM, g_u32ACCOutWidth, g_u32ACCOutHeight);

    return HI_SUCCESS;
}

static HI_S32 pq_hal_SetY2RMatrix(HI_DRV_COLOR_SPACE_E enInCS, HI_DRV_COLOR_SPACE_E enOutCS, HI_PQ_HDR_CFG *pstPqHdrCfg)
{
    pstPqHdrCfg->stY2R.u16ScaleY2R = u16ScaleY2R;

    switch (enInCS)
    {
        case HI_DRV_CS_BT2020_YUV_LIMITED:
            memcpy(pstPqHdrCfg->stY2R.as16M33Y2R,   as16M33Y2R_2020L,   sizeof(HI_S16) * 9);
            memcpy(pstPqHdrCfg->stY2R.as16DcInY2R,  as16DcInY2R_L,      sizeof(HI_S16) * 3);
            break;
        case HI_DRV_CS_BT2020_YUV_FULL:
            memcpy(pstPqHdrCfg->stY2R.as16M33Y2R,   as16M33Y2R_2020F,   sizeof(HI_S16) * 9);
            memcpy(pstPqHdrCfg->stY2R.as16DcInY2R,  as16DcInY2R_F,      sizeof(HI_S16) * 3);
            break;
        case HI_DRV_CS_BT709_YUV_LIMITED:
            memcpy(pstPqHdrCfg->stY2R.as16M33Y2R,   as16M33Y2R_709L,    sizeof(HI_S16) * 9);
            memcpy(pstPqHdrCfg->stY2R.as16DcInY2R,  as16DcInY2R_L,      sizeof(HI_S16) * 3);
            break;
        case HI_DRV_CS_BT709_YUV_FULL:
            memcpy(pstPqHdrCfg->stY2R.as16M33Y2R,   as16M33Y2R_709F,    sizeof(HI_S16) * 9);
            memcpy(pstPqHdrCfg->stY2R.as16DcInY2R,  as16DcInY2R_F,      sizeof(HI_S16) * 3);
            break;
        case HI_DRV_CS_BT601_YUV_LIMITED:
            memcpy(pstPqHdrCfg->stY2R.as16M33Y2R,   as16M33Y2R_601L,    sizeof(HI_S16) * 9);
            memcpy(pstPqHdrCfg->stY2R.as16DcInY2R,  as16DcInY2R_L,      sizeof(HI_S16) * 3);
            break;
        case HI_DRV_CS_BT601_YUV_FULL:
            memcpy(pstPqHdrCfg->stY2R.as16M33Y2R,   as16M33Y2R_601F,    sizeof(HI_S16) * 9);
            memcpy(pstPqHdrCfg->stY2R.as16DcInY2R,  as16DcInY2R_F,      sizeof(HI_S16) * 3);
            break;
        default:
            memcpy(pstPqHdrCfg->stY2R.as16M33Y2R,   as16M33Y2R_2020L,   sizeof(HI_S16) * 9);
            memcpy(pstPqHdrCfg->stY2R.as16DcInY2R,  as16DcInY2R_L,      sizeof(HI_S16) * 3);
            break;
    }

    memcpy(pstPqHdrCfg->stY2R.as16DcOutY2R, as16DcOutY2R, sizeof(HI_S16) * 3);
    pstPqHdrCfg->stY2R.u16ClipMinY2R = u16ClipMinY2R;
    pstPqHdrCfg->stY2R.u16ClipMaxY2R = u16ClipMaxY2R;

    return HI_SUCCESS;
}

static HI_S32 pq_hal_SetGamutMappingPara(HI_DRV_COLOR_SPACE_E enInCS, HI_DRV_COLOR_SPACE_E enOutCS, HI_PQ_HDR_CFG *pstPqHdrCfg)
{
    /* GamutMapping */
    pstPqHdrCfg->stGMAP.u16ScaleGMAP = u16ScaleGMap;

    pstPqHdrCfg->stGMAP.u32ClipMinGMAP = u32ClipMinGMap;
    pstPqHdrCfg->stGMAP.u32ClipMaxGMAP = u32ClipMaxGMap;

    if (((HI_DRV_CS_BT2020_YUV_LIMITED == enInCS) || (HI_DRV_CS_BT2020_YUV_FULL == enInCS))
        && ((HI_DRV_CS_BT709_YUV_LIMITED == enOutCS) || (HI_DRV_CS_BT709_YUV_FULL == enOutCS))) /* 2020->709 */
    {
        memcpy(pstPqHdrCfg->stGMAP.as16M33GMAP, as16M33GMap_2020to709, sizeof(HI_S16) * 9);
    }
    else if (((HI_DRV_CS_BT2020_YUV_LIMITED == enInCS) || (HI_DRV_CS_BT2020_YUV_FULL == enInCS))
             && ((HI_DRV_CS_BT2020_YUV_LIMITED == enOutCS) || (HI_DRV_CS_BT2020_YUV_FULL == enOutCS)))/* 2020->2020 */
    {
        memcpy(pstPqHdrCfg->stGMAP.as16M33GMAP, as16M33GMap_linear, sizeof(HI_S16) * 9);
    }
    else if (((HI_DRV_CS_BT709_YUV_LIMITED == enInCS) || (HI_DRV_CS_BT709_YUV_FULL == enInCS))
             && ((HI_DRV_CS_BT2020_YUV_LIMITED == enOutCS) || (HI_DRV_CS_BT2020_YUV_FULL == enOutCS)))/* 709->2020 */
    {
        memcpy(pstPqHdrCfg->stGMAP.as16M33GMAP, as16M33GMap_709to2020, sizeof(HI_S16) * 9);
    }
    else if (((HI_DRV_CS_BT601_YUV_LIMITED == enInCS) || (HI_DRV_CS_BT601_YUV_FULL == enInCS))
             && ((HI_DRV_CS_BT2020_YUV_LIMITED == enOutCS) || (HI_DRV_CS_BT2020_YUV_FULL == enOutCS)))/* 601->2020 */
    {
        memcpy(pstPqHdrCfg->stGMAP.as16M33GMAP, as16M33GMAP_Pal_601_2020, sizeof(HI_S16) * 9);
    }
    else if (((HI_DRV_CS_BT601_YUV_LIMITED == enInCS) || (HI_DRV_CS_BT601_YUV_FULL == enInCS))
             && ((HI_DRV_CS_BT709_YUV_LIMITED == enOutCS) || (HI_DRV_CS_BT709_YUV_FULL == enOutCS)))/* 601->709 */
    {
        memcpy(pstPqHdrCfg->stGMAP.as16M33GMAP, as16M33GMAP_Pal_601_709, sizeof(HI_S16) * 9);
    }
    else
    {
        memcpy(pstPqHdrCfg->stGMAP.as16M33GMAP, as16M33GMap_linear, sizeof(HI_S16) * 9);
    }

    return HI_SUCCESS;
}

static HI_S32 pq_hal_SetHDRTMap(HI_DRV_COLOR_SPACE_E enInCS, HI_PQ_HDR_CFG *pstPqHdrCfg)
{
    pstPqHdrCfg->stTMAP.u16ScaleLumaCal = u16ScaleLumaCal;

    if ((HI_DRV_CS_BT709_YUV_LIMITED == enInCS) || (HI_DRV_CS_BT709_YUV_FULL == enInCS))
    {
        memcpy(pstPqHdrCfg->stTMAP.au16M3LumaCal, au16M3LumaCal_709, sizeof(HI_U16) * 3);
    }
    else if ((HI_DRV_CS_BT2020_YUV_LIMITED == enInCS) || (HI_DRV_CS_BT2020_YUV_FULL == enInCS))
    {
        memcpy(pstPqHdrCfg->stTMAP.au16M3LumaCal, au16M3LumaCal_2020, sizeof(HI_U16) * 3);
    }
    else
    {
        memcpy(pstPqHdrCfg->stTMAP.au16M3LumaCal, au16M3LumaCal_601, sizeof(HI_U16) * 3);
    }

    pstPqHdrCfg->stTMAP.u32ClipMinTM = u32ClipMinTM;
    pstPqHdrCfg->stTMAP.u32ClipMaxTM = u32ClipMaxTM;
    memset(pstPqHdrCfg->stTMAP.as32TMOff, 0, sizeof(HI_S32) * 3);
    pqprint(PQ_PRN_HDR, "HdrMode:%d\n", g_u32HdrMode);

    switch (sg_enHDRMode)
    {
        case HI_PQ_HDR_MODE_HDR10_TO_SDR:
            pstPqHdrCfg->stTMAP.u16ScaleCoefTM = u16ScaleCoefTM_HDR10toSDR;
            memcpy(pstPqHdrCfg->stTMAP.au32StepTM, au32TMapStep, sizeof(HI_U32) * PQ_TMAP_SEG_SIZE);
            memcpy(pstPqHdrCfg->stTMAP.au32PosTM,  au32TMapPos,  sizeof(HI_U32) * PQ_TMAP_SEG_SIZE);
            memcpy(pstPqHdrCfg->stTMAP.au32NumTM,  au32TMapNum,  sizeof(HI_U32) * PQ_TMAP_SEG_SIZE);
            memcpy(g_au32TM_LUT, au32TMLut_HDR10toSDR_Vivid, sizeof(HI_U32) * PQ_TMAP_LUT_SIZE);
            break;
        case HI_PQ_HDR_MODE_HDR10_TO_HDR10:
            pstPqHdrCfg->stTMAP.u16ScaleCoefTM = u16ScaleCoefTM_Linear;
            memcpy(pstPqHdrCfg->stTMAP.au32StepTM, au32TMapStep, sizeof(HI_U32) * PQ_TMAP_SEG_SIZE);
            memcpy(pstPqHdrCfg->stTMAP.au32PosTM,  au32TMapPos,  sizeof(HI_U32) * PQ_TMAP_SEG_SIZE);
            memcpy(pstPqHdrCfg->stTMAP.au32NumTM,  au32TMapNum,  sizeof(HI_U32) * PQ_TMAP_SEG_SIZE);
            memcpy(g_au32TM_LUT, au32TMLut_Linear, sizeof(HI_U32) * PQ_TMAP_LUT_SIZE);
            break;
        case HI_PQ_HDR_MODE_HDR10_TO_HLG:
            pstPqHdrCfg->stTMAP.u16ScaleCoefTM = u16ScaleCoefTM_HDR102HLG;
            memcpy(pstPqHdrCfg->stTMAP.au32StepTM, au32TMapStep, sizeof(HI_U32) * PQ_TMAP_SEG_SIZE);
            memcpy(pstPqHdrCfg->stTMAP.au32PosTM,  au32TMapPos,  sizeof(HI_U32) * PQ_TMAP_SEG_SIZE);
            memcpy(pstPqHdrCfg->stTMAP.au32NumTM,  au32TMapNum,  sizeof(HI_U32) * PQ_TMAP_SEG_SIZE);
            memcpy(g_au32TM_LUT, au32TMLut_HDR102HLG, sizeof(HI_U32) * PQ_TMAP_LUT_SIZE);
            break;
        case HI_PQ_HDR_MODE_HLG_TO_SDR:
            pstPqHdrCfg->stTMAP.u16ScaleCoefTM = u16ScaleCoefTM_HLG2SDR;
            memcpy(pstPqHdrCfg->stTMAP.au32StepTM, au32TMapStep, sizeof(HI_U32) * PQ_TMAP_SEG_SIZE);
            memcpy(pstPqHdrCfg->stTMAP.au32PosTM,  au32TMapPos,  sizeof(HI_U32) * PQ_TMAP_SEG_SIZE);
            memcpy(pstPqHdrCfg->stTMAP.au32NumTM,  au32TMapNum,  sizeof(HI_U32) * PQ_TMAP_SEG_SIZE);
            memcpy(g_au32TM_LUT, au32TMLut_HLG2SDR, sizeof(HI_U32) * PQ_TMAP_LUT_SIZE);
            break;
        case HI_PQ_HDR_MODE_HLG_TO_HDR10:
            pstPqHdrCfg->stTMAP.u16ScaleCoefTM = u16ScaleLumaCal;
            memcpy(pstPqHdrCfg->stTMAP.au32StepTM, au32TMapStep, sizeof(HI_U32) * PQ_TMAP_SEG_SIZE);
            memcpy(pstPqHdrCfg->stTMAP.au32PosTM,  au32TMapPos,  sizeof(HI_U32) * PQ_TMAP_SEG_SIZE);
            memcpy(pstPqHdrCfg->stTMAP.au32NumTM,  au32TMapNum,  sizeof(HI_U32) * PQ_TMAP_SEG_SIZE);
            memcpy(g_au32TM_LUT, au32TMLut_HLGtoHDR10, sizeof(HI_U32) * PQ_TMAP_LUT_SIZE);
            break;
        case HI_PQ_HDR_MODE_SLF_TO_SDR:
            HI_WARN_PQ("pq_hal_SetHDRTMap : Error __LINE__ == %d\n", __LINE__);
            pstPqHdrCfg->stTMAP.u16ScaleCoefTM = u16ScaleCoefTM_HDR10toSDR;
            memcpy(pstPqHdrCfg->stTMAP.au32StepTM, au32TMapStep, sizeof(HI_U32) * PQ_TMAP_SEG_SIZE);
            memcpy(pstPqHdrCfg->stTMAP.au32PosTM,  au32TMapPos,  sizeof(HI_U32) * PQ_TMAP_SEG_SIZE);
            memcpy(pstPqHdrCfg->stTMAP.au32NumTM,  au32TMapNum,  sizeof(HI_U32) * PQ_TMAP_SEG_SIZE);
            memcpy(g_au32TM_LUT, au32TMLut_HDR10toSDR, sizeof(HI_U32) * PQ_TMAP_LUT_SIZE);
            break;
        case HI_PQ_HDR_MODE_SLF_TO_HDR10:
            HI_WARN_PQ("pq_hal_SetHDRTMap : Error __LINE__ == %d\n", __LINE__);
            pstPqHdrCfg->stTMAP.u16ScaleCoefTM = u16ScaleCoefTM_HDR10toSDR;
            memcpy(pstPqHdrCfg->stTMAP.au32StepTM, au32TMapStep, sizeof(HI_U32) * PQ_TMAP_SEG_SIZE);
            memcpy(pstPqHdrCfg->stTMAP.au32PosTM,  au32TMapPos,  sizeof(HI_U32) * PQ_TMAP_SEG_SIZE);
            memcpy(pstPqHdrCfg->stTMAP.au32NumTM,  au32TMapNum,  sizeof(HI_U32) * PQ_TMAP_SEG_SIZE);
            memcpy(g_au32TM_LUT, au32TMLut_HDR10toSDR, sizeof(HI_U32) * PQ_TMAP_LUT_SIZE);
            break;
        case HI_PQ_HDR_MODE_SDR_TO_HDR10:
            pstPqHdrCfg->stTMAP.u16ScaleCoefTM = u16ScaleCoefTM_SDRtoHDR1000;
            memcpy(pstPqHdrCfg->stTMAP.au32StepTM, au32TMapStep, sizeof(HI_U32) * PQ_TMAP_SEG_SIZE);
            memcpy(pstPqHdrCfg->stTMAP.au32PosTM,  au32TMapPos,  sizeof(HI_U32) * PQ_TMAP_SEG_SIZE);
            memcpy(pstPqHdrCfg->stTMAP.au32NumTM,  au32TMapNum,  sizeof(HI_U32) * PQ_TMAP_SEG_SIZE);
            memcpy(g_au32TM_LUT, au32TMLut_SDRtoHDR1000, sizeof(HI_U32) * PQ_TMAP_LUT_SIZE);
            break;
        case HI_PQ_HDR_MODE_SDR_TO_HLG:
            pstPqHdrCfg->stTMAP.u16ScaleCoefTM = u16ScaleCoefTM_SDR2HLG;
            memcpy(pstPqHdrCfg->stTMAP.au32StepTM, au32TMapStep, sizeof(HI_U32) * PQ_TMAP_SEG_SIZE);
            memcpy(pstPqHdrCfg->stTMAP.au32PosTM,  au32TMapPos,  sizeof(HI_U32) * PQ_TMAP_SEG_SIZE);
            memcpy(pstPqHdrCfg->stTMAP.au32NumTM,  au32TMapNum,  sizeof(HI_U32) * PQ_TMAP_SEG_SIZE);
            memcpy(g_au32TM_LUT, au32TMLut_SDR2HLG, sizeof(HI_U32) * PQ_TMAP_LUT_SIZE);
            break;
        default:
            pstPqHdrCfg->stTMAP.u16ScaleCoefTM = u16ScaleCoefTM_HDR10toSDR;
            memcpy(pstPqHdrCfg->stTMAP.au32StepTM, au32TMapStep, sizeof(HI_U32) * PQ_TMAP_SEG_SIZE);
            memcpy(pstPqHdrCfg->stTMAP.au32PosTM,  au32TMapPos,  sizeof(HI_U32) * PQ_TMAP_SEG_SIZE);
            memcpy(pstPqHdrCfg->stTMAP.au32NumTM,  au32TMapNum,  sizeof(HI_U32) * PQ_TMAP_SEG_SIZE);
            memcpy(g_au32TM_LUT, au32TMLut_HDR10toSDR_Vivid, sizeof(HI_U32) * PQ_TMAP_LUT_SIZE);
    }

    sg_u32TMScaleCoef = pstPqHdrCfg->stTMAP.u16ScaleCoefTM ;
    memcpy(pstPqHdrCfg->stTMAP.pu32LUTTM, g_au32TM_LUT, sizeof(HI_U32) * PQ_TMAP_LUT_SIZE);

    if (0 == sg_u32HdrTmMode)
    {
        memcpy(g_au32TM_PQTool, g_au32TM_LUT, sizeof(g_au32TM_PQTool));
    }
    else if (1 == sg_u32HdrTmMode)
    {
        memcpy(g_au32TM_LUT, g_au32TM_PQTool, sizeof(g_au32TM_PQTool));
    }
    else if (2 == sg_u32HdrTmMode)
    {
        memcpy(pstPqHdrCfg->stTMAP.au32StepTM, g_u32TMLutXStep, sizeof(HI_U32) * PQ_TMAP_SEG_SIZE);
        memcpy(pstPqHdrCfg->stTMAP.au32PosTM,  g_u32TMLutXPos,  sizeof(HI_U32) * PQ_TMAP_SEG_SIZE);
        memcpy(pstPqHdrCfg->stTMAP.au32NumTM,  g_u32TMLutXNum,  sizeof(HI_U32) * PQ_TMAP_SEG_SIZE);
        memcpy(g_au32TM_LUT, g_au32TM_PQTool, sizeof(g_au32TM_PQTool));
    }
    else if (3 == sg_u32HdrTmMode)
    {
        memcpy(pstPqHdrCfg->stTMAP.pu32LUTTM, sg_stHdrTmapUsePara.au32TMLut, sizeof(HI_U32) * PQ_TMAP_LUT_SIZE);
        HiPP_HDR_HDR10toSDRTMApi(pstPqHdrCfg, &stDminfo);
    }

    return HI_SUCCESS;
}

static HI_S32 pq_hal_SetR2YMatrix(HI_DRV_COLOR_SPACE_E enOutCS, HI_PQ_HDR_CFG *pstPqHdrCfg)
{
    /* RGB2YUV */
    pstPqHdrCfg->stR2Y.u16ScaleR2Y = u16ScaleR2Y;

    switch (enOutCS)
    {
        case HI_DRV_CS_BT2020_YUV_LIMITED:
            memcpy(pstPqHdrCfg->stR2Y.as16M33R2Y,   as16M33RF2YL_2020NCL,  sizeof(HI_S16) * 9);
            memcpy(pstPqHdrCfg->stR2Y.as16DcInR2Y,  as16DcInRF2YL,         sizeof(HI_S16) * 3);
            memcpy(pstPqHdrCfg->stR2Y.as16DcOutR2Y, as16DcOutRF2YL,        sizeof(HI_S16) * 3);
            pstPqHdrCfg->stR2Y.u16ClipMinR2Y_Y = u16ClipMinRF2YL;
            pstPqHdrCfg->stR2Y.u16ClipMaxR2Y_Y = u16ClipMaxRF2YL;
            break;
        case HI_DRV_CS_BT2020_YUV_FULL:
            memcpy(pstPqHdrCfg->stR2Y.as16M33R2Y,   as16M33RF2YF_2020NCL,  sizeof(HI_S16) * 9);
            memcpy(pstPqHdrCfg->stR2Y.as16DcInR2Y,  as16DcInRF2YF,         sizeof(HI_S16) * 3);
            memcpy(pstPqHdrCfg->stR2Y.as16DcOutR2Y, as16DcOutRF2YF,        sizeof(HI_S16) * 3);
            pstPqHdrCfg->stR2Y.u16ClipMinR2Y_Y = u16ClipMinRF2YF;
            pstPqHdrCfg->stR2Y.u16ClipMaxR2Y_Y = u16ClipMaxRF2YF;
            break;
        case HI_DRV_CS_BT709_YUV_LIMITED:
            memcpy(pstPqHdrCfg->stR2Y.as16M33R2Y,   as16M33RF2YL_709,      sizeof(HI_S16) * 9);
            memcpy(pstPqHdrCfg->stR2Y.as16DcInR2Y,  as16DcInRF2YL,         sizeof(HI_S16) * 3);
            memcpy(pstPqHdrCfg->stR2Y.as16DcOutR2Y, as16DcOutRF2YL,        sizeof(HI_S16) * 3);
            pstPqHdrCfg->stR2Y.u16ClipMinR2Y_Y = u16ClipMinRF2YL;
            pstPqHdrCfg->stR2Y.u16ClipMaxR2Y_Y = u16ClipMaxRF2YL;
            break;
        case HI_DRV_CS_BT709_YUV_FULL:
            memcpy(pstPqHdrCfg->stR2Y.as16M33R2Y,   as16M33RF2YF_709,      sizeof(HI_S16) * 9);
            memcpy(pstPqHdrCfg->stR2Y.as16DcInR2Y,  as16DcInRF2YF,         sizeof(HI_S16) * 3);
            memcpy(pstPqHdrCfg->stR2Y.as16DcOutR2Y, as16DcOutRF2YF,        sizeof(HI_S16) * 3);
            pstPqHdrCfg->stR2Y.u16ClipMinR2Y_Y = u16ClipMinRF2YF;
            pstPqHdrCfg->stR2Y.u16ClipMaxR2Y_Y = u16ClipMaxRF2YF;
            break;
        case HI_DRV_CS_BT601_YUV_LIMITED:
            memcpy(pstPqHdrCfg->stR2Y.as16M33R2Y,   as16M33RF2YL_601,      sizeof(HI_S16) * 9);
            memcpy(pstPqHdrCfg->stR2Y.as16DcInR2Y,  as16DcInRF2YL,         sizeof(HI_S16) * 3);
            memcpy(pstPqHdrCfg->stR2Y.as16DcOutR2Y, as16DcOutRF2YL,        sizeof(HI_S16) * 3);
            pstPqHdrCfg->stR2Y.u16ClipMinR2Y_Y = u16ClipMinRF2YL;
            pstPqHdrCfg->stR2Y.u16ClipMaxR2Y_Y = u16ClipMaxRF2YL;
            break;
        case HI_DRV_CS_BT601_YUV_FULL:
            memcpy(pstPqHdrCfg->stR2Y.as16M33R2Y,   as16M33RF2YF_601,      sizeof(HI_S16) * 9);
            memcpy(pstPqHdrCfg->stR2Y.as16DcInR2Y,  as16DcInRF2YF,         sizeof(HI_S16) * 3);
            memcpy(pstPqHdrCfg->stR2Y.as16DcOutR2Y, as16DcOutRF2YF,        sizeof(HI_S16) * 3);
            pstPqHdrCfg->stR2Y.u16ClipMinR2Y_Y = u16ClipMinRF2YF;
            pstPqHdrCfg->stR2Y.u16ClipMaxR2Y_Y = u16ClipMaxRF2YF;
            break;
        case HI_DRV_CS_BT2020_RGB_FULL: /*R2R */
        case HI_DRV_CS_BT709_RGB_FULL: /*R2R */
        case HI_DRV_CS_BT601_RGB_FULL: /*R2R */
            memcpy(pstPqHdrCfg->stR2Y.as16M33R2Y,   as16M33RF2RF,          sizeof(HI_S16) * 9);
            memcpy(pstPqHdrCfg->stR2Y.as16DcInR2Y,  as16DcInRF2RF,         sizeof(HI_S16) * 3);
            memcpy(pstPqHdrCfg->stR2Y.as16DcOutR2Y, as16DcOutRF2RF,        sizeof(HI_S16) * 3);
            pstPqHdrCfg->stR2Y.u16ClipMinR2Y_Y = u16ClipMinRF2RF;
            pstPqHdrCfg->stR2Y.u16ClipMaxR2Y_Y = u16ClipMaxRF2RF;
            break;
        default:
            memcpy(pstPqHdrCfg->stR2Y.as16M33R2Y,   as16M33RF2YL_709,      sizeof(HI_S16) * 9);
            memcpy(pstPqHdrCfg->stR2Y.as16DcInR2Y,  as16DcInRF2YL,         sizeof(HI_S16) * 3);
            memcpy(pstPqHdrCfg->stR2Y.as16DcOutR2Y, as16DcOutRF2YL,        sizeof(HI_S16) * 3);
            pstPqHdrCfg->stR2Y.u16ClipMinR2Y_Y = u16ClipMinRF2YL;
            pstPqHdrCfg->stR2Y.u16ClipMaxR2Y_Y = u16ClipMaxRF2YL;
            break;
    }

    return HI_SUCCESS;
}

static HI_S32 pq_hal_AdjustHDRTmCurve(HI_PQ_HDR_CFG *pstPqHdrCfg)
{
    HI_S8 i;
    pstPqHdrCfg->stTMAP.u16ScaleLumaCal = u16ScaleLumaCal;
    if (g_u32BrightCvStr < 50)
    {
        for (i = 0; i < 64; i++)
        {
            pstPqHdrCfg->stTMAP.pu32LUTTM[i] = (g_u32BrightCvStr * pstPqHdrCfg->stTMAP.pu32LUTTM[i] + (50 - g_u32BrightCvStr) *
                                                sg_stHdrTmapUsePara.au32TM_B0[i]) / 50;
        }
    }
    else if (g_u32BrightCvStr > 50)
    {
        for (i = 0; i < 64; i++)
        {
            pstPqHdrCfg->stTMAP.pu32LUTTM[i] = ((100 - g_u32BrightCvStr) * pstPqHdrCfg->stTMAP.pu32LUTTM[i] + (g_u32BrightCvStr - 50) *
                                                sg_stHdrTmapUsePara.au32TM_B100[i]) / 50;
        }
    }

    if (g_u32DarkCvStr < 50)
    {
        for (i = 0; i < 64; i++)
        {
            pstPqHdrCfg->stTMAP.pu32LUTTM[i] = (g_u32DarkCvStr * pstPqHdrCfg->stTMAP.pu32LUTTM[i] + (50 - g_u32DarkCvStr) *
                                                sg_stHdrTmapUsePara.au32TM_D0[i]) / 50;
        }
    }
    else if (g_u32DarkCvStr > 50)
    {
        for (i = 0; i < 64; i++)
        {
            pstPqHdrCfg->stTMAP.pu32LUTTM[i] = ((100 - g_u32DarkCvStr) * pstPqHdrCfg->stTMAP.pu32LUTTM[i] + (g_u32DarkCvStr - 50) *
                                                sg_stHdrTmapUsePara.au32TM_D100[i]) / 50;
        }
    }
    pqprint(PQ_PRN_HDR, "Curve_para:M:%d,AccD:%d,AccB:%d,D:%d,B:%d\n", \
            g_u32HdrMode, g_u32ACCDarkStr, g_u32ACCBrightStr, g_u32DarkCvStr, g_u32BrightCvStr);

    return HI_SUCCESS;
}


static HI_S32 pq_hal_GetHDR10toHDR10Cfg(HI_DRV_COLOR_SPACE_E enInCS, HI_DRV_COLOR_SPACE_E enOutCS, HI_PQ_HDR_CFG *pstPqHdrCfg)
{
    /* WCG */
    if (enInCS != enOutCS)
    {
        pstPqHdrCfg->bY2REn         = HI_TRUE;
        pstPqHdrCfg->bDegammaEn     = HI_TRUE;
        pstPqHdrCfg->bTMapEn        = HI_FALSE;
        pstPqHdrCfg->bGMapEn        = HI_TRUE;
        pstPqHdrCfg->bGammaEn       = HI_TRUE;
        pstPqHdrCfg->bDitherEn      = HI_TRUE;
        pstPqHdrCfg->bR2YEn         = HI_TRUE;
        pstPqHdrCfg->bChromaAdjEn   = HI_FALSE;  /* no exist in 98mv200*/
        pstPqHdrCfg->bBT2020CL      = HI_FALSE;  /* no exist in 98mv200*/

        pstPqHdrCfg->bGMapPosSel    = HI_TRUE;   /* true : gmapping after tmap; false : gmapping before tmap*/
        pstPqHdrCfg->bDitherMode    = HI_FALSE;
    }
    else
    {
        pstPqHdrCfg->bY2REn         = HI_FALSE;
        pstPqHdrCfg->bDegammaEn     = HI_FALSE;
        pstPqHdrCfg->bTMapEn        = HI_FALSE;
        pstPqHdrCfg->bGMapEn        = HI_FALSE;
        pstPqHdrCfg->bGammaEn       = HI_FALSE;
        pstPqHdrCfg->bDitherEn      = HI_FALSE;
        pstPqHdrCfg->bR2YEn         = HI_FALSE;
        pstPqHdrCfg->bChromaAdjEn   = HI_FALSE;  /* no exist in 98mv200*/
        pstPqHdrCfg->bBT2020CL      = HI_FALSE;  /* no exist in 98mv200*/

        pstPqHdrCfg->bGMapPosSel    = HI_FALSE;  /* true : gmapping after tmap; false : gmapping before tmap*/
        pstPqHdrCfg->bDitherMode    = HI_FALSE;
    }

    /* YUV2RGB */
    pq_hal_SetY2RMatrix(enInCS, enOutCS, pstPqHdrCfg);

    /* DeGamma */
    memcpy(pstPqHdrCfg->stDeGmm.au32Step, au32DeGmm_step, sizeof(HI_U32) * PQ_DEGMM_SEG_SIZE);
    memcpy(pstPqHdrCfg->stDeGmm.au32Pos,  au32DeGmm_pos,  sizeof(HI_U32) * PQ_DEGMM_SEG_SIZE);
    memcpy(pstPqHdrCfg->stDeGmm.au32Num,  au32DeGmm_num,  sizeof(HI_U32) * PQ_DEGMM_SEG_SIZE);
    memcpy(pstPqHdrCfg->stDeGmm.pu32LUT,  au32DeGmmLut_PQ, sizeof(HI_U32) * PQ_DEGMM_LUT_SIZE);

    /* ToneMapping Tmap */
    pq_hal_SetHDRTMap(enInCS, pstPqHdrCfg);

    /* GamutMapping */
    pq_hal_SetGamutMappingPara(enInCS, enOutCS, pstPqHdrCfg);

    /*  Gamma */
    memcpy(pstPqHdrCfg->stGmm.au32Step, au32GmmStep,        sizeof(HI_U32) * PQ_GMM_SEG_SIZE);
    memcpy(pstPqHdrCfg->stGmm.au32Pos,  au32GmmPos,         sizeof(HI_U32) * PQ_GMM_SEG_SIZE);
    memcpy(pstPqHdrCfg->stGmm.au32Num,  au32GmmNum,         sizeof(HI_U32) * PQ_GMM_SEG_SIZE);
    memcpy(pstPqHdrCfg->stGmm.pu32LUT,  au32GmmLut_PQ10000, sizeof(HI_U32) * PQ_GMM_LUT_SIZE);

    /* RGB2YUV */
    pq_hal_SetR2YMatrix(enOutCS, pstPqHdrCfg);
    /* Hdr Normal Adjust */
    PQ_hal_CalCSCCoefRGBtoYCbCr(g_u32Contrast, g_u32Satu, g_u32Hue,
                                g_u32Red, g_u32Green, g_u32Blue, pstPqHdrCfg->stR2Y.as16M33R2Y, g_aDstCSCTable);
    memcpy(pstPqHdrCfg->stR2Y.as16M33R2Y,   g_aDstCSCTable, sizeof(HI_S16) * 9);

    memcpy(g_as16DcOutR2Y, pstPqHdrCfg->stR2Y.as16DcOutR2Y, sizeof(HI_S16) * 3);
    g_as16DcOutR2Y[0] = g_as16DcOutR2Y[0] + (g_u32Bright - 128) * 4;
    memcpy(pstPqHdrCfg->stR2Y.as16DcOutR2Y, g_as16DcOutR2Y, sizeof(HI_S16) * 3);

    return HI_SUCCESS;
}

static HI_S32 pq_hal_GetHDR10toSDRCfg(HI_DRV_COLOR_SPACE_E enInCS, HI_DRV_COLOR_SPACE_E enOutCS, HI_PQ_HDR_CFG *pstPqHdrCfg)
{
    pstPqHdrCfg->bY2REn         = HI_TRUE;
    pstPqHdrCfg->bDegammaEn     = HI_TRUE;
    pstPqHdrCfg->bTMapEn        = HI_TRUE;
    pstPqHdrCfg->bGMapEn        = HI_TRUE;
    pstPqHdrCfg->bGammaEn       = HI_TRUE;
    pstPqHdrCfg->bDitherEn      = HI_TRUE;
    pstPqHdrCfg->bR2YEn         = HI_TRUE;
    pstPqHdrCfg->bChromaAdjEn   = HI_FALSE;  /* no exist in 98mv200*/
    pstPqHdrCfg->bBT2020CL      = HI_FALSE;  /* no exist in 98mv200*/
    pstPqHdrCfg->bGMapPosSel    = HI_TRUE;   /* true : gmapping after tmap; false : gmapping before tmap*/
    pstPqHdrCfg->bDitherMode    = HI_TRUE;

    /* YUV2RGB */
    pq_hal_SetY2RMatrix(enInCS, enOutCS, pstPqHdrCfg);
    //pstPqHdrCfg->stY2R.u16ClipMaxY2R = u16ClipMaxY2R_1000;

    /* DeGamma */
    memcpy(pstPqHdrCfg->stDeGmm.au32Step, au32DeGmm_step, sizeof(HI_U32) * PQ_DEGMM_SEG_SIZE);
    memcpy(pstPqHdrCfg->stDeGmm.au32Pos,  au32DeGmm_pos,  sizeof(HI_U32) * PQ_DEGMM_SEG_SIZE);
    memcpy(pstPqHdrCfg->stDeGmm.au32Num,  au32DeGmm_num,  sizeof(HI_U32) * PQ_DEGMM_SEG_SIZE);
    memcpy(pstPqHdrCfg->stDeGmm.pu32LUT,  au32DeGmmLut_PQ, sizeof(HI_U32) * PQ_DEGMM_LUT_SIZE);

    /* ToneMapping Tmap */
    pq_hal_SetHDRTMap(enInCS, pstPqHdrCfg);

    pq_hal_AdjustHDRTmCurve(pstPqHdrCfg);
    /* ToneMapping Tmap  adjust with acc histgram*/
    PQ_HAL_CalcHdrTmapACCHistGram(pstPqHdrCfg);
    /* GamutMapping */
    pq_hal_SetGamutMappingPara(enInCS, enOutCS, pstPqHdrCfg);

    /*  Gamma */
    memcpy(pstPqHdrCfg->stGmm.au32Step, au32GmmStep,    sizeof(HI_U32) * PQ_GMM_SEG_SIZE);
    memcpy(pstPqHdrCfg->stGmm.au32Pos,  au32GmmPos,     sizeof(HI_U32) * PQ_GMM_SEG_SIZE);
    memcpy(pstPqHdrCfg->stGmm.au32Num,  au32GmmNum,     sizeof(HI_U32) * PQ_GMM_SEG_SIZE);
    memcpy(pstPqHdrCfg->stGmm.pu32LUT,  au32GmmLut_22,  sizeof(HI_U32) * PQ_GMM_LUT_SIZE);

    /* RGB2YUV */
    pq_hal_SetR2YMatrix(enOutCS, pstPqHdrCfg);

    /* Hdr Offset Adjust */
    PQ_hal_HdrOffsetCalCSCCoefRGBtoYCbCr(g_u32HdrOffsetContrast, g_u32HdrOffsetSatu, g_u32HdrOffsetHue,
                                g_u32HdrOffsetRed, g_u32HdrOffsetGreen, g_u32HdrOffsetBlue, pstPqHdrCfg->stR2Y.as16M33R2Y, g_aDstHdrOffsetCSCTable);
    memcpy(pstPqHdrCfg->stR2Y.as16M33R2Y,   g_aDstHdrOffsetCSCTable, sizeof(HI_S16) * 9);

    memcpy(g_as16HdrOffsetDcOutR2Y, pstPqHdrCfg->stR2Y.as16DcOutR2Y, sizeof(HI_S16) * 3);
    g_as16HdrOffsetDcOutR2Y[0] = g_as16HdrOffsetDcOutR2Y[0] + (g_u32HdrOffsetBright - 128) * 4;

 /* Hdr Normal Adjust */
    PQ_hal_CalCSCCoefRGBtoYCbCr(g_u32Contrast, g_u32Satu, g_u32Hue,
                                g_u32Red, g_u32Green, g_u32Blue, pstPqHdrCfg->stR2Y.as16M33R2Y, g_aDstCSCTable);
    memcpy(pstPqHdrCfg->stR2Y.as16M33R2Y,   g_aDstCSCTable, sizeof(HI_S16) * 9);

    g_as16HdrOffsetDcOutR2Y[0] = g_as16HdrOffsetDcOutR2Y[0] + (g_u32Bright - 128) * 4;
    memcpy(pstPqHdrCfg->stR2Y.as16DcOutR2Y, g_as16DcOutR2Y, sizeof(HI_S16) * 3);

    return HI_SUCCESS;
}

static HI_S32 pq_hal_GetHDR10toHLGCfg(HI_DRV_COLOR_SPACE_E enInCS, HI_DRV_COLOR_SPACE_E enOutCS, HI_PQ_HDR_CFG *pstPqHdrCfg)
{
    pstPqHdrCfg->bY2REn         = HI_TRUE ;
    pstPqHdrCfg->bDegammaEn     = HI_TRUE ;
    pstPqHdrCfg->bTMapEn        = HI_TRUE ;
    pstPqHdrCfg->bGMapEn        = HI_TRUE ;
    pstPqHdrCfg->bGammaEn       = HI_TRUE ;
    pstPqHdrCfg->bDitherEn      = HI_TRUE ;
    pstPqHdrCfg->bR2YEn         = HI_TRUE ;
    pstPqHdrCfg->bGMapPosSel    = HI_TRUE ;  /* true : gmapping after tmap; false : gmapping before tmap*/
    pstPqHdrCfg->bDitherMode    = HI_TRUE ;

    /* YUV2RGB */
    pq_hal_SetY2RMatrix(enInCS, enOutCS, pstPqHdrCfg);

    /* DeGamma */
    memcpy(pstPqHdrCfg->stDeGmm.au32Step, au32DeGmm_step, sizeof(HI_U32) * PQ_DEGMM_SEG_SIZE);
    memcpy(pstPqHdrCfg->stDeGmm.au32Pos,  au32DeGmm_pos,  sizeof(HI_U32) * PQ_DEGMM_SEG_SIZE);
    memcpy(pstPqHdrCfg->stDeGmm.au32Num,  au32DeGmm_num,  sizeof(HI_U32) * PQ_DEGMM_SEG_SIZE);
    memcpy(pstPqHdrCfg->stDeGmm.pu32LUT,  au32DeGmmLut_PQ, sizeof(HI_U32) * PQ_DEGMM_LUT_SIZE);
    /* ToneMapping */
    pq_hal_SetHDRTMap(enInCS, pstPqHdrCfg);

    /* GamutMapping */
    pq_hal_SetGamutMappingPara(enInCS, enOutCS, pstPqHdrCfg);

    /*  Gamma */
    memcpy(pstPqHdrCfg->stGmm.au32Step, au32GmmStep, sizeof(HI_U32) * PQ_GMM_SEG_SIZE);
    memcpy(pstPqHdrCfg->stGmm.au32Pos,  au32GmmPos,  sizeof(HI_U32) * PQ_GMM_SEG_SIZE);
    memcpy(pstPqHdrCfg->stGmm.au32Num,  au32GmmNum,  sizeof(HI_U32) * PQ_GMM_SEG_SIZE);
    memcpy(pstPqHdrCfg->stGmm.pu32LUT,  au32GmmLut_HLG,  sizeof(HI_U32) * PQ_GMM_LUT_SIZE);

    /* RGB2YUV */
    pq_hal_SetR2YMatrix(enOutCS, pstPqHdrCfg);
    /* Hdr Normal Adjust */
    PQ_hal_CalCSCCoefRGBtoYCbCr(g_u32Contrast, g_u32Satu, g_u32Hue,
                                g_u32Red, g_u32Green, g_u32Blue, pstPqHdrCfg->stR2Y.as16M33R2Y, g_aDstCSCTable);
    memcpy(pstPqHdrCfg->stR2Y.as16M33R2Y,   g_aDstCSCTable, sizeof(HI_S16) * 9);

    memcpy(g_as16DcOutR2Y, pstPqHdrCfg->stR2Y.as16DcOutR2Y, sizeof(HI_S16) * 3);
    g_as16DcOutR2Y[0] = g_as16DcOutR2Y[0] + (g_u32Bright - 128) * 4;
    memcpy(pstPqHdrCfg->stR2Y.as16DcOutR2Y, g_as16DcOutR2Y, sizeof(HI_S16) * 3);

    return HI_SUCCESS;
}

HI_S32 pq_hal_GetHLGtoSDRCfg(HI_DRV_COLOR_SPACE_E enInCS, HI_DRV_COLOR_SPACE_E enOutCS, HI_PQ_HDR_CFG *pstPqHdrCfg)
{
    pstPqHdrCfg->bY2REn         = HI_TRUE ;
    pstPqHdrCfg->bDegammaEn     = HI_TRUE ;
    pstPqHdrCfg->bTMapEn        = HI_TRUE ;
    pstPqHdrCfg->bGMapEn        = HI_TRUE ;
    pstPqHdrCfg->bGammaEn       = HI_TRUE ;
    pstPqHdrCfg->bDitherEn      = HI_TRUE ;
    pstPqHdrCfg->bR2YEn         = HI_TRUE ;
    pstPqHdrCfg->bGMapPosSel    = HI_TRUE ;  /* true : gmapping after tmap; false : gmapping before tmap*/
    pstPqHdrCfg->bDitherMode    = HI_TRUE ;

    /* YUV2RGB */
    pq_hal_SetY2RMatrix(enInCS, enOutCS, pstPqHdrCfg);

    /* DeGamma */
    memcpy(pstPqHdrCfg->stDeGmm.au32Step, au32DeGmm_step,   sizeof(HI_U32) * PQ_DEGMM_SEG_SIZE);
    memcpy(pstPqHdrCfg->stDeGmm.au32Pos,  au32DeGmm_pos,    sizeof(HI_U32) * PQ_DEGMM_SEG_SIZE);
    memcpy(pstPqHdrCfg->stDeGmm.au32Num,  au32DeGmm_num,    sizeof(HI_U32) * PQ_DEGMM_SEG_SIZE);
    memcpy(pstPqHdrCfg->stDeGmm.pu32LUT,  au32DeGmmLut_HLG, sizeof(HI_U32) * PQ_DEGMM_LUT_SIZE);

    /* ToneMapping */
    pq_hal_SetHDRTMap(enInCS, pstPqHdrCfg);

    /* GamutMapping */
    pq_hal_SetGamutMappingPara(enInCS, enOutCS, pstPqHdrCfg);

    /*  Gamma */
    memcpy(pstPqHdrCfg->stGmm.au32Step, au32GmmStep,    sizeof(HI_U32) * PQ_GMM_SEG_SIZE);
    memcpy(pstPqHdrCfg->stGmm.au32Pos,  au32GmmPos,     sizeof(HI_U32) * PQ_GMM_SEG_SIZE);
    memcpy(pstPqHdrCfg->stGmm.au32Num,  au32GmmNum,     sizeof(HI_U32) * PQ_GMM_SEG_SIZE);
    memcpy(pstPqHdrCfg->stGmm.pu32LUT,  au32GmmLut_22,  sizeof(HI_U32) * PQ_GMM_LUT_SIZE);

    /* RGB2YUV */
    pq_hal_SetR2YMatrix(enOutCS, pstPqHdrCfg);
    /* Hdr Normal Adjust */
    PQ_hal_CalCSCCoefRGBtoYCbCr(g_u32Contrast, g_u32Satu, g_u32Hue,
                                g_u32Red, g_u32Green, g_u32Blue, pstPqHdrCfg->stR2Y.as16M33R2Y, g_aDstCSCTable);
    memcpy(pstPqHdrCfg->stR2Y.as16M33R2Y,   g_aDstCSCTable, sizeof(HI_S16) * 9);

    memcpy(g_as16DcOutR2Y, pstPqHdrCfg->stR2Y.as16DcOutR2Y, sizeof(HI_S16) * 3);
    g_as16DcOutR2Y[0] = g_as16DcOutR2Y[0] + (g_u32Bright - 128) * 4;
    memcpy(pstPqHdrCfg->stR2Y.as16DcOutR2Y, g_as16DcOutR2Y, sizeof(HI_S16) * 3);

    return HI_SUCCESS;
}

static HI_S32 pq_hal_GetHLGtoHDR10Cfg(HI_DRV_COLOR_SPACE_E enInCS, HI_DRV_COLOR_SPACE_E enOutCS, HI_PQ_HDR_CFG *pstPqHdrCfg)
{
    pstPqHdrCfg->bY2REn         = HI_TRUE ;
    pstPqHdrCfg->bDegammaEn     = HI_TRUE ;
    pstPqHdrCfg->bTMapEn        = HI_TRUE ;
    pstPqHdrCfg->bGMapEn        = HI_TRUE ;
    pstPqHdrCfg->bGammaEn       = HI_TRUE ;
    pstPqHdrCfg->bDitherEn      = HI_TRUE ;
    pstPqHdrCfg->bR2YEn         = HI_TRUE ;
    pstPqHdrCfg->bGMapPosSel    = HI_TRUE ;  /* true : gmapping after tmap; false : gmapping before tmap*/
    pstPqHdrCfg->bDitherMode    = HI_TRUE ;

    /* YUV2RGB */
    pq_hal_SetY2RMatrix(enInCS, enOutCS, pstPqHdrCfg);

    /* DeGamma */
    memcpy(pstPqHdrCfg->stDeGmm.au32Step, au32DeGmm_step,   sizeof(HI_U32) * PQ_DEGMM_SEG_SIZE);
    memcpy(pstPqHdrCfg->stDeGmm.au32Pos,  au32DeGmm_pos,    sizeof(HI_U32) * PQ_DEGMM_SEG_SIZE);
    memcpy(pstPqHdrCfg->stDeGmm.au32Num,  au32DeGmm_num,    sizeof(HI_U32) * PQ_DEGMM_SEG_SIZE);
    memcpy(pstPqHdrCfg->stDeGmm.pu32LUT,  au32DeGmmLut_HLG, sizeof(HI_U32) * PQ_DEGMM_LUT_SIZE);

    /* ToneMapping */
    pq_hal_SetHDRTMap(enInCS, pstPqHdrCfg);

    /* GamutMapping */
    pq_hal_SetGamutMappingPara(enInCS, enOutCS, pstPqHdrCfg);

    /*  Gamma */
    memcpy(pstPqHdrCfg->stGmm.au32Step, au32GmmStep,        sizeof(HI_U32) * PQ_GMM_SEG_SIZE);
    memcpy(pstPqHdrCfg->stGmm.au32Pos,  au32GmmPos,         sizeof(HI_U32) * PQ_GMM_SEG_SIZE);
    memcpy(pstPqHdrCfg->stGmm.au32Num,  au32GmmNum,         sizeof(HI_U32) * PQ_GMM_SEG_SIZE);
    memcpy(pstPqHdrCfg->stGmm.pu32LUT,  au32GmmLut_PQ1250,  sizeof(HI_U32) * PQ_GMM_LUT_SIZE);

    /* RGB2YUV */
    pq_hal_SetR2YMatrix(enOutCS, pstPqHdrCfg);
    /* Hdr Normal Adjust */
    PQ_hal_CalCSCCoefRGBtoYCbCr(g_u32Contrast, g_u32Satu, g_u32Hue,
                                g_u32Red, g_u32Green, g_u32Blue, pstPqHdrCfg->stR2Y.as16M33R2Y, g_aDstCSCTable);
    memcpy(pstPqHdrCfg->stR2Y.as16M33R2Y,   g_aDstCSCTable, sizeof(HI_S16) * 9);

    memcpy(g_as16DcOutR2Y, pstPqHdrCfg->stR2Y.as16DcOutR2Y, sizeof(HI_S16) * 3);
    g_as16DcOutR2Y[0] = g_as16DcOutR2Y[0] + (g_u32Bright - 128) * 4;
    memcpy(pstPqHdrCfg->stR2Y.as16DcOutR2Y, g_as16DcOutR2Y, sizeof(HI_S16) * 3);

    return HI_SUCCESS;
}

static HI_S32 pq_hal_GetHLGtoHLGCfg(HI_DRV_COLOR_SPACE_E enInCS, HI_DRV_COLOR_SPACE_E enOutCS, HI_PQ_HDR_CFG *pstPqHdrCfg)
{
    /* WCG */
    if (enInCS != enOutCS)
    {
        pstPqHdrCfg->bY2REn         = HI_TRUE;
        pstPqHdrCfg->bDegammaEn     = HI_TRUE;
        pstPqHdrCfg->bTMapEn        = HI_FALSE;
        pstPqHdrCfg->bGMapEn        = HI_TRUE;
        pstPqHdrCfg->bGammaEn       = HI_TRUE;
        pstPqHdrCfg->bDitherEn      = HI_TRUE;
        pstPqHdrCfg->bR2YEn         = HI_TRUE;
        pstPqHdrCfg->bChromaAdjEn   = HI_FALSE;  /* no exist in 98mv200*/
        pstPqHdrCfg->bBT2020CL      = HI_FALSE;  /* no exist in 98mv200*/

        pstPqHdrCfg->bGMapPosSel    = HI_TRUE;   /* true : gmapping after tmap; false : gmapping before tmap*/
        pstPqHdrCfg->bDitherMode    = HI_TRUE;
    }
    else
    {
        pstPqHdrCfg->bY2REn         = HI_FALSE;
        pstPqHdrCfg->bDegammaEn     = HI_FALSE;
        pstPqHdrCfg->bTMapEn        = HI_FALSE;
        pstPqHdrCfg->bGMapEn        = HI_FALSE;
        pstPqHdrCfg->bGammaEn       = HI_FALSE;
        pstPqHdrCfg->bDitherEn      = HI_FALSE;
        pstPqHdrCfg->bR2YEn         = HI_FALSE;
        pstPqHdrCfg->bChromaAdjEn   = HI_FALSE;  /* no exist in 98mv200*/
        pstPqHdrCfg->bBT2020CL      = HI_FALSE;  /* no exist in 98mv200*/

        pstPqHdrCfg->bGMapPosSel    = HI_FALSE;  /* true : gmapping after tmap; false : gmapping before tmap*/
        pstPqHdrCfg->bDitherMode    = HI_FALSE;
    }

    /* YUV2RGB */
    pq_hal_SetY2RMatrix(enInCS, enOutCS, pstPqHdrCfg);

    /* DeGamma */
    memcpy(pstPqHdrCfg->stDeGmm.au32Step, au32DeGmm_step,   sizeof(HI_U32) * PQ_DEGMM_SEG_SIZE);
    memcpy(pstPqHdrCfg->stDeGmm.au32Pos,  au32DeGmm_pos,    sizeof(HI_U32) * PQ_DEGMM_SEG_SIZE);
    memcpy(pstPqHdrCfg->stDeGmm.au32Num,  au32DeGmm_num,    sizeof(HI_U32) * PQ_DEGMM_SEG_SIZE);
    memcpy(pstPqHdrCfg->stDeGmm.pu32LUT,  au32DeGmmLut_HLG, sizeof(HI_U32) * PQ_DEGMM_LUT_SIZE);

    /* ToneMapping Tmap */
    pq_hal_SetHDRTMap(enInCS, pstPqHdrCfg);

    /* GamutMapping */
    pq_hal_SetGamutMappingPara(enInCS, enOutCS, pstPqHdrCfg);

    /*  Gamma */
    memcpy(pstPqHdrCfg->stGmm.au32Step, au32GmmStep,    sizeof(HI_U32) * PQ_GMM_SEG_SIZE);
    memcpy(pstPqHdrCfg->stGmm.au32Pos,  au32GmmPos,     sizeof(HI_U32) * PQ_GMM_SEG_SIZE);
    memcpy(pstPqHdrCfg->stGmm.au32Num,  au32GmmNum,     sizeof(HI_U32) * PQ_GMM_SEG_SIZE);
    memcpy(pstPqHdrCfg->stGmm.pu32LUT,  au32GmmLut_HLG, sizeof(HI_U32) * PQ_GMM_LUT_SIZE);

    /* RGB2YUV */
    pq_hal_SetR2YMatrix(enOutCS, pstPqHdrCfg);
    /* Hdr Normal Adjust */
    PQ_hal_CalCSCCoefRGBtoYCbCr(g_u32Contrast, g_u32Satu, g_u32Hue,
                                g_u32Red, g_u32Green, g_u32Blue, pstPqHdrCfg->stR2Y.as16M33R2Y, g_aDstCSCTable);
    memcpy(pstPqHdrCfg->stR2Y.as16M33R2Y,   g_aDstCSCTable, sizeof(HI_S16) * 9);

    memcpy(g_as16DcOutR2Y, pstPqHdrCfg->stR2Y.as16DcOutR2Y, sizeof(HI_S16) * 3);
    g_as16DcOutR2Y[0] = g_as16DcOutR2Y[0] + (g_u32Bright - 128) * 4;
    memcpy(pstPqHdrCfg->stR2Y.as16DcOutR2Y, g_as16DcOutR2Y, sizeof(HI_S16) * 3);

    return HI_SUCCESS;
}

/* SLFtoSDR not the right cfg */
static HI_S32 pq_hal_GetSLFtoSDRCfg(HI_DRV_COLOR_SPACE_E enInCS, HI_DRV_COLOR_SPACE_E enOutCS, HI_PQ_HDR_CFG *pstPqHdrCfg)
{
    pstPqHdrCfg->bY2REn         = HI_TRUE ;
    pstPqHdrCfg->bDegammaEn     = HI_TRUE ;
    pstPqHdrCfg->bTMapEn        = HI_TRUE ;
    pstPqHdrCfg->bGMapEn        = HI_TRUE ;
    pstPqHdrCfg->bGammaEn       = HI_TRUE ;
    pstPqHdrCfg->bDitherEn      = HI_TRUE ;
    pstPqHdrCfg->bR2YEn         = HI_TRUE ;
    pstPqHdrCfg->bGMapPosSel    = HI_TRUE ;  /* true : gmapping after tmap; false : gmapping before tmap*/
    pstPqHdrCfg->bDitherMode    = HI_TRUE ;

    /* YUV2RGB */
    pq_hal_SetY2RMatrix(enInCS, enOutCS, pstPqHdrCfg);

    /* DeGamma */
    memcpy(pstPqHdrCfg->stDeGmm.au32Step, au32DeGmm_step, sizeof(HI_U32) * PQ_DEGMM_SEG_SIZE);
    memcpy(pstPqHdrCfg->stDeGmm.au32Pos,  au32DeGmm_pos,  sizeof(HI_U32) * PQ_DEGMM_SEG_SIZE);
    memcpy(pstPqHdrCfg->stDeGmm.au32Num,  au32DeGmm_num,  sizeof(HI_U32) * PQ_DEGMM_SEG_SIZE);
    memcpy(pstPqHdrCfg->stDeGmm.pu32LUT,  au32DeGmmLut_22, sizeof(HI_U32) * PQ_DEGMM_LUT_SIZE); /* need to be modified */

    /* ToneMapping */
    pq_hal_SetHDRTMap(enInCS, pstPqHdrCfg);

    /* GamutMapping */
    pq_hal_SetGamutMappingPara(enInCS, enOutCS, pstPqHdrCfg);

    /*  Gamma */
    memcpy(pstPqHdrCfg->stGmm.au32Step, au32GmmStep,    sizeof(HI_U32) * PQ_GMM_SEG_SIZE);
    memcpy(pstPqHdrCfg->stGmm.au32Pos,  au32GmmPos,     sizeof(HI_U32) * PQ_GMM_SEG_SIZE);
    memcpy(pstPqHdrCfg->stGmm.au32Num,  au32GmmNum,     sizeof(HI_U32) * PQ_GMM_SEG_SIZE);
    memcpy(pstPqHdrCfg->stGmm.pu32LUT,  au32GmmLut_22,  sizeof(HI_U32) * PQ_GMM_LUT_SIZE);/* need to be modified */

    /* RGB2YUV */
    pq_hal_SetR2YMatrix(enOutCS, pstPqHdrCfg);
    /* Hdr Normal Adjust */
    PQ_hal_CalCSCCoefRGBtoYCbCr(g_u32Contrast, g_u32Satu, g_u32Hue,
                                g_u32Red, g_u32Green, g_u32Blue, pstPqHdrCfg->stR2Y.as16M33R2Y, g_aDstCSCTable);
    memcpy(pstPqHdrCfg->stR2Y.as16M33R2Y,   g_aDstCSCTable, sizeof(HI_S16) * 9);

    memcpy(g_as16DcOutR2Y, pstPqHdrCfg->stR2Y.as16DcOutR2Y, sizeof(HI_S16) * 3);
    g_as16DcOutR2Y[0] = g_as16DcOutR2Y[0] + (g_u32Bright - 128) * 4;
    memcpy(pstPqHdrCfg->stR2Y.as16DcOutR2Y, g_as16DcOutR2Y, sizeof(HI_S16) * 3);

    return HI_SUCCESS;
}


/* SLFtoHDR10 not the right cfg */
static HI_S32 pq_hal_GetSLFtoHDR10Cfg(HI_DRV_COLOR_SPACE_E enInCS, HI_DRV_COLOR_SPACE_E enOutCS, HI_PQ_HDR_CFG *pstPqHdrCfg)
{
    pstPqHdrCfg->bY2REn         = HI_TRUE ;
    pstPqHdrCfg->bDegammaEn     = HI_TRUE ;
    pstPqHdrCfg->bTMapEn        = HI_TRUE ;
    pstPqHdrCfg->bGMapEn        = HI_TRUE ;
    pstPqHdrCfg->bGammaEn       = HI_TRUE ;
    pstPqHdrCfg->bDitherEn      = HI_TRUE ;
    pstPqHdrCfg->bR2YEn         = HI_TRUE ;
    pstPqHdrCfg->bGMapPosSel    = HI_TRUE ;  /* true : gmapping after tmap; false : gmapping before tmap*/
    pstPqHdrCfg->bDitherMode    = HI_TRUE ;

    /* YUV2RGB */
    pq_hal_SetY2RMatrix(enInCS, enOutCS, pstPqHdrCfg);

    /* DeGamma */
    memcpy(pstPqHdrCfg->stDeGmm.au32Step, au32DeGmm_step, sizeof(HI_U32) * PQ_DEGMM_SEG_SIZE);
    memcpy(pstPqHdrCfg->stDeGmm.au32Pos,  au32DeGmm_pos,  sizeof(HI_U32) * PQ_DEGMM_SEG_SIZE);
    memcpy(pstPqHdrCfg->stDeGmm.au32Num,  au32DeGmm_num,  sizeof(HI_U32) * PQ_DEGMM_SEG_SIZE);
    memcpy(pstPqHdrCfg->stDeGmm.pu32LUT,  au32DeGmmLut_22, sizeof(HI_U32) * PQ_DEGMM_LUT_SIZE); /* need to be modified */

    /* ToneMapping */
    pq_hal_SetHDRTMap(enInCS, pstPqHdrCfg);

    /* GamutMapping */
    pq_hal_SetGamutMappingPara(enInCS, enOutCS, pstPqHdrCfg);

    /*  Gamma */
    memcpy(pstPqHdrCfg->stGmm.au32Step, au32GmmStep,        sizeof(HI_U32) * PQ_GMM_SEG_SIZE);
    memcpy(pstPqHdrCfg->stGmm.au32Pos,  au32GmmPos,         sizeof(HI_U32) * PQ_GMM_SEG_SIZE);
    memcpy(pstPqHdrCfg->stGmm.au32Num,  au32GmmNum,         sizeof(HI_U32) * PQ_GMM_SEG_SIZE);
    memcpy(pstPqHdrCfg->stGmm.pu32LUT,  au32GmmLut_PQ1250,  sizeof(HI_U32) * PQ_GMM_LUT_SIZE);/* need to be modified */

    /* RGB2YUV */
    pq_hal_SetR2YMatrix(enOutCS, pstPqHdrCfg);
    /* Hdr Normal Adjust */
    PQ_hal_CalCSCCoefRGBtoYCbCr(g_u32Contrast, g_u32Satu, g_u32Hue,
                                g_u32Red, g_u32Green, g_u32Blue, pstPqHdrCfg->stR2Y.as16M33R2Y, g_aDstCSCTable);
    memcpy(pstPqHdrCfg->stR2Y.as16M33R2Y,   g_aDstCSCTable, sizeof(HI_S16) * 9);

    memcpy(g_as16DcOutR2Y, pstPqHdrCfg->stR2Y.as16DcOutR2Y, sizeof(HI_S16) * 3);
    g_as16DcOutR2Y[0] = g_as16DcOutR2Y[0] + (g_u32Bright - 128) * 4;
    memcpy(pstPqHdrCfg->stR2Y.as16DcOutR2Y, g_as16DcOutR2Y, sizeof(HI_S16) * 3);

    return HI_SUCCESS;
}

static HI_S32 pq_hal_GetSDRtoHDR10Cfg(HI_DRV_COLOR_SPACE_E enInCS, HI_DRV_COLOR_SPACE_E enOutCS, HI_PQ_HDR_CFG *pstPqHdrCfg)
{

    pstPqHdrCfg->bY2REn         = HI_TRUE ;
    pstPqHdrCfg->bDegammaEn     = HI_TRUE ;
    pstPqHdrCfg->bTMapEn        = HI_TRUE ;
    pstPqHdrCfg->bGMapEn        = HI_TRUE ;
    pstPqHdrCfg->bGammaEn       = HI_TRUE ;
    pstPqHdrCfg->bDitherEn      = HI_TRUE ;
    pstPqHdrCfg->bR2YEn         = HI_TRUE ;
    pstPqHdrCfg->bGMapPosSel    = HI_TRUE;  /* true : gmapping after tmap; false : gmapping before tmap*/
    pstPqHdrCfg->bDitherMode    = HI_TRUE ;

    /* YUV2RGB */
    pq_hal_SetY2RMatrix(enInCS, enOutCS, pstPqHdrCfg);

    /* DeGamma */
    memcpy(pstPqHdrCfg->stDeGmm.au32Step, au32DeGmm_sdr2hdr_step,   sizeof(HI_U32) * PQ_DEGMM_SEG_SIZE);
    memcpy(pstPqHdrCfg->stDeGmm.au32Pos,  au32DeGmm_sdr2hdr_pos,    sizeof(HI_U32) * PQ_DEGMM_SEG_SIZE);
    memcpy(pstPqHdrCfg->stDeGmm.au32Num,  au32DeGmm_sdr2hdr_num,    sizeof(HI_U32) * PQ_DEGMM_SEG_SIZE);
    memcpy(pstPqHdrCfg->stDeGmm.pu32LUT,  au32DeGmmLut_24,          sizeof(HI_U32) * PQ_DEGMM_LUT_SIZE);

    /* ToneMapping */
    pq_hal_SetHDRTMap(enInCS, pstPqHdrCfg);

    /* GamutMapping */
    pq_hal_SetGamutMappingPara(enInCS, enOutCS, pstPqHdrCfg);

    /*  Gamma */
    memcpy(pstPqHdrCfg->stGmm.au32Step, au32GmmStep,        sizeof(HI_U32) * PQ_GMM_SEG_SIZE);
    memcpy(pstPqHdrCfg->stGmm.au32Pos,  au32GmmPos,         sizeof(HI_U32) * PQ_GMM_SEG_SIZE);
    memcpy(pstPqHdrCfg->stGmm.au32Num,  au32GmmNum,         sizeof(HI_U32) * PQ_GMM_SEG_SIZE);
    memcpy(pstPqHdrCfg->stGmm.pu32LUT,  au32GmmLut_PQ1000, sizeof(HI_U32) * PQ_GMM_LUT_SIZE);

    /* RGB2YUV */
    pq_hal_SetR2YMatrix(enOutCS, pstPqHdrCfg);
    /* Hdr Normal Adjust */
    PQ_hal_CalCSCCoefRGBtoYCbCr(g_u32Contrast, g_u32Satu, g_u32Hue,
                                g_u32Red, g_u32Green, g_u32Blue, pstPqHdrCfg->stR2Y.as16M33R2Y, g_aDstCSCTable);
    memcpy(pstPqHdrCfg->stR2Y.as16M33R2Y,   g_aDstCSCTable, sizeof(HI_S16) * 9);

    memcpy(g_as16DcOutR2Y, pstPqHdrCfg->stR2Y.as16DcOutR2Y, sizeof(HI_S16) * 3);
    g_as16DcOutR2Y[0] = g_as16DcOutR2Y[0] + (g_u32Bright - 128) * 4;
    memcpy(pstPqHdrCfg->stR2Y.as16DcOutR2Y, g_as16DcOutR2Y, sizeof(HI_S16) * 3);

    return HI_SUCCESS;
}

static HI_S32 pq_hal_GetSDRtoSDRCfg(HI_DRV_COLOR_SPACE_E enInCS, HI_DRV_COLOR_SPACE_E enOutCS, HI_PQ_HDR_CFG *pstPqHdrCfg)
{
    /* WCG */
    if (enInCS != enOutCS)
    {
        pstPqHdrCfg->bY2REn         = HI_TRUE;
        pstPqHdrCfg->bDegammaEn     = HI_TRUE;
        pstPqHdrCfg->bTMapEn        = HI_FALSE;
        pstPqHdrCfg->bGMapEn        = HI_TRUE;
        pstPqHdrCfg->bGammaEn       = HI_TRUE;
        pstPqHdrCfg->bDitherEn      = HI_TRUE;
        pstPqHdrCfg->bR2YEn         = HI_TRUE;
        pstPqHdrCfg->bChromaAdjEn   = HI_TRUE;  /* no exist in 98mv200*/
        pstPqHdrCfg->bBT2020CL      = HI_FALSE; /* no exist in 98mv200*/

        pstPqHdrCfg->bGMapPosSel    = HI_TRUE;  /* true : gmapping after tmap; false : gmapping before tmap*/
        pstPqHdrCfg->bDitherMode    = HI_TRUE;
    }
    else
    {
        pstPqHdrCfg->bY2REn         = HI_FALSE;
        pstPqHdrCfg->bDegammaEn     = HI_FALSE;
        pstPqHdrCfg->bTMapEn        = HI_FALSE;
        pstPqHdrCfg->bGMapEn        = HI_FALSE;
        pstPqHdrCfg->bGammaEn       = HI_FALSE;
        pstPqHdrCfg->bDitherEn      = HI_FALSE;
        pstPqHdrCfg->bR2YEn         = HI_FALSE;
        pstPqHdrCfg->bChromaAdjEn   = HI_FALSE;  /* no exist in 98mv200*/
        pstPqHdrCfg->bBT2020CL      = HI_FALSE;  /* no exist in 98mv200*/

        pstPqHdrCfg->bGMapPosSel    = HI_FALSE;  /* true : gmapping after tmap; false : gmapping before tmap*/
        pstPqHdrCfg->bDitherMode    = HI_FALSE;
    }

    /* YUV2RGB */
    pq_hal_SetY2RMatrix(enInCS, enOutCS, pstPqHdrCfg);

    /* DeGamma */
    memcpy(pstPqHdrCfg->stDeGmm.au32Step, au32DeGmm_step, sizeof(HI_U32) * PQ_DEGMM_SEG_SIZE);
    memcpy(pstPqHdrCfg->stDeGmm.au32Pos,  au32DeGmm_pos,  sizeof(HI_U32) * PQ_DEGMM_SEG_SIZE);
    memcpy(pstPqHdrCfg->stDeGmm.au32Num,  au32DeGmm_num,  sizeof(HI_U32) * PQ_DEGMM_SEG_SIZE);
    memcpy(pstPqHdrCfg->stDeGmm.pu32LUT,  au32DeGmmLut_22, sizeof(HI_U32) * PQ_DEGMM_LUT_SIZE);

    /* ToneMapping Tmap */
    pq_hal_SetHDRTMap(enInCS, pstPqHdrCfg);

    /* GamutMapping */
    pq_hal_SetGamutMappingPara(enInCS, enOutCS, pstPqHdrCfg);

    /*  Gamma */
    memcpy(pstPqHdrCfg->stGmm.au32Step, au32GmmStep,    sizeof(HI_U32) * PQ_GMM_SEG_SIZE);
    memcpy(pstPqHdrCfg->stGmm.au32Pos,  au32GmmPos,     sizeof(HI_U32) * PQ_GMM_SEG_SIZE);
    memcpy(pstPqHdrCfg->stGmm.au32Num,  au32GmmNum,     sizeof(HI_U32) * PQ_GMM_SEG_SIZE);
    memcpy(pstPqHdrCfg->stGmm.pu32LUT,  au32GmmLut_22,  sizeof(HI_U32) * PQ_GMM_LUT_SIZE);

    /* RGB2YUV */
    pq_hal_SetR2YMatrix(enOutCS, pstPqHdrCfg);
    /* Hdr Normal Adjust */
    PQ_hal_CalCSCCoefRGBtoYCbCr(g_u32Contrast, g_u32Satu, g_u32Hue,
                                g_u32Red, g_u32Green, g_u32Blue, pstPqHdrCfg->stR2Y.as16M33R2Y, g_aDstCSCTable);
    memcpy(pstPqHdrCfg->stR2Y.as16M33R2Y,   g_aDstCSCTable, sizeof(HI_S16) * 9);

    memcpy(g_as16DcOutR2Y, pstPqHdrCfg->stR2Y.as16DcOutR2Y, sizeof(HI_S16) * 3);
    g_as16DcOutR2Y[0] = g_as16DcOutR2Y[0] + (g_u32Bright - 128) * 4;
    memcpy(pstPqHdrCfg->stR2Y.as16DcOutR2Y, g_as16DcOutR2Y, sizeof(HI_S16) * 3);

    return HI_SUCCESS;
}

static HI_S32 pq_hal_GetSDRtoHLGCfg(HI_DRV_COLOR_SPACE_E enInCS, HI_DRV_COLOR_SPACE_E enOutCS, HI_PQ_HDR_CFG *pstPqHdrCfg)
{
    pstPqHdrCfg->bY2REn         = HI_TRUE ;
    pstPqHdrCfg->bDegammaEn     = HI_TRUE ;
    pstPqHdrCfg->bTMapEn        = HI_TRUE ;
    pstPqHdrCfg->bGMapEn        = HI_TRUE ;
    pstPqHdrCfg->bGammaEn       = HI_TRUE ;
    pstPqHdrCfg->bDitherEn      = HI_TRUE ;
    pstPqHdrCfg->bR2YEn         = HI_TRUE ;
    pstPqHdrCfg->bGMapPosSel    = HI_TRUE;  /* true : gmapping after tmap; false : gmapping before tmap*/
    pstPqHdrCfg->bDitherMode    = HI_TRUE ;

    /* YUV2RGB */
    pq_hal_SetY2RMatrix(enInCS, enOutCS, pstPqHdrCfg);

    /* DeGamma */
    memcpy(pstPqHdrCfg->stDeGmm.au32Step, au32DeGmm_sdr2hdr_step, sizeof(HI_U32) * PQ_DEGMM_SEG_SIZE);
    memcpy(pstPqHdrCfg->stDeGmm.au32Pos,  au32DeGmm_sdr2hdr_pos,  sizeof(HI_U32) * PQ_DEGMM_SEG_SIZE);
    memcpy(pstPqHdrCfg->stDeGmm.au32Num,  au32DeGmm_sdr2hdr_num,  sizeof(HI_U32) * PQ_DEGMM_SEG_SIZE);
    memcpy(pstPqHdrCfg->stDeGmm.pu32LUT,  au32DeGmmLut_24, sizeof(HI_U32) * PQ_DEGMM_LUT_SIZE);
    /* ToneMapping */
    pq_hal_SetHDRTMap(enInCS, pstPqHdrCfg);

    /* GamutMapping */
    pq_hal_SetGamutMappingPara(enInCS, enOutCS, pstPqHdrCfg);

    /*  Gamma */
    memcpy(pstPqHdrCfg->stGmm.au32Step, au32GmmStep, sizeof(HI_U32) * PQ_GMM_SEG_SIZE);
    memcpy(pstPqHdrCfg->stGmm.au32Pos,  au32GmmPos,  sizeof(HI_U32) * PQ_GMM_SEG_SIZE);
    memcpy(pstPqHdrCfg->stGmm.au32Num,  au32GmmNum,  sizeof(HI_U32) * PQ_GMM_SEG_SIZE);
    memcpy(pstPqHdrCfg->stGmm.pu32LUT,  au32GmmLut_HLG,  sizeof(HI_U32) * PQ_GMM_LUT_SIZE);

    /* RGB2YUV */
    pq_hal_SetR2YMatrix(enOutCS, pstPqHdrCfg);
    /* Hdr Normal Adjust */
    PQ_hal_CalCSCCoefRGBtoYCbCr(g_u32Contrast, g_u32Satu, g_u32Hue,
                                g_u32Red, g_u32Green, g_u32Blue, pstPqHdrCfg->stR2Y.as16M33R2Y, g_aDstCSCTable);
    memcpy(pstPqHdrCfg->stR2Y.as16M33R2Y,   g_aDstCSCTable, sizeof(HI_S16) * 9);

    memcpy(g_as16DcOutR2Y, pstPqHdrCfg->stR2Y.as16DcOutR2Y, sizeof(HI_S16) * 3);
    g_as16DcOutR2Y[0] = g_as16DcOutR2Y[0] + (g_u32Bright - 128) * 4;
    memcpy(pstPqHdrCfg->stR2Y.as16DcOutR2Y, g_as16DcOutR2Y, sizeof(HI_S16) * 3);

    return HI_SUCCESS;
}

HI_S32 PQ_HAL_GetHDRCfg(HI_PQ_WIN_HDR_INFO *pstWinHdrInfo, HI_PQ_HDR_CFG *pstPqHdrCfg)
{
    HI_S32 s32Ret = HI_FAILURE;

    PQ_CHECK_NULL_PTR(pstWinHdrInfo);
    PQ_CHECK_NULL_PTR(pstPqHdrCfg);

    pg_stPqHdrCfg = pstPqHdrCfg;

    stDminfo.u32SrcMaxPQ = pstWinHdrInfo->unHDRInfo.stHDR10Info.stMasteringInfo.u32MaxDisplayMasteringLuminance;
    stDminfo.u32SrcMinPQ = pstWinHdrInfo->unHDRInfo.stHDR10Info.stMasteringInfo.u32MinDisplayMasteringLuminance;

    if ((HI_DRV_VIDEO_FRAME_TYPE_HDR10 == pstWinHdrInfo->enSrcFrameType) && (HI_PQ_DISP_TYPE_HDR10 == pstWinHdrInfo->enDispType))
    {
        sg_enHDRMode = HI_PQ_HDR_MODE_HDR10_TO_HDR10;
        s32Ret       = pq_hal_GetHDR10toHDR10Cfg(pstWinHdrInfo->enInCS, pstWinHdrInfo->enOutCS, pstPqHdrCfg);
    }
    else if ((HI_DRV_VIDEO_FRAME_TYPE_HDR10 == pstWinHdrInfo->enSrcFrameType) && (HI_PQ_DISP_TYPE_NORMAL == pstWinHdrInfo->enDispType))
    {
        sg_enHDRMode = HI_PQ_HDR_MODE_HDR10_TO_SDR;
        s32Ret       = pq_hal_GetHDR10toSDRCfg(pstWinHdrInfo->enInCS, pstWinHdrInfo->enOutCS, pstPqHdrCfg);
    }
    else if ((HI_DRV_VIDEO_FRAME_TYPE_HDR10 == pstWinHdrInfo->enSrcFrameType) && (HI_PQ_DISP_TYPE_HLG == pstWinHdrInfo->enDispType))
    {
        sg_enHDRMode = HI_PQ_HDR_MODE_HDR10_TO_HLG;
        s32Ret       = pq_hal_GetHDR10toHLGCfg(pstWinHdrInfo->enInCS, pstWinHdrInfo->enOutCS, pstPqHdrCfg);
    }
    else if ((HI_DRV_VIDEO_FRAME_TYPE_HLG == pstWinHdrInfo->enSrcFrameType) && (HI_PQ_DISP_TYPE_NORMAL == pstWinHdrInfo->enDispType))
    {
        sg_enHDRMode = HI_PQ_HDR_MODE_HLG_TO_SDR;
        s32Ret       = pq_hal_GetHLGtoSDRCfg(pstWinHdrInfo->enInCS, pstWinHdrInfo->enOutCS, pstPqHdrCfg);
    }
    else if ((HI_DRV_VIDEO_FRAME_TYPE_HLG == pstWinHdrInfo->enSrcFrameType) && (HI_PQ_DISP_TYPE_HDR10 == pstWinHdrInfo->enDispType))
    {
        sg_enHDRMode = HI_PQ_HDR_MODE_HLG_TO_HDR10;
        s32Ret       = pq_hal_GetHLGtoHDR10Cfg(pstWinHdrInfo->enInCS, pstWinHdrInfo->enOutCS, pstPqHdrCfg);
    }
    else if ((HI_DRV_VIDEO_FRAME_TYPE_HLG == pstWinHdrInfo->enSrcFrameType) && (HI_PQ_DISP_TYPE_HLG == pstWinHdrInfo->enDispType))
    {
        sg_enHDRMode = HI_PQ_HDR_MODE_HLG_TO_HLG;
        s32Ret       = pq_hal_GetHLGtoHLGCfg(pstWinHdrInfo->enInCS, pstWinHdrInfo->enOutCS, pstPqHdrCfg);
    }
    else if ((HI_DRV_VIDEO_FRAME_TYPE_SLF == pstWinHdrInfo->enSrcFrameType) && (HI_PQ_DISP_TYPE_NORMAL == pstWinHdrInfo->enDispType))
    {
        HI_WARN_PQ("PQ_HAL_GetHDRCfg : Error __LINE__ == %d\n", __LINE__);
        sg_enHDRMode = HI_PQ_HDR_MODE_SLF_TO_SDR;
        s32Ret       = pq_hal_GetSLFtoSDRCfg(pstWinHdrInfo->enInCS, pstWinHdrInfo->enOutCS, pstPqHdrCfg);
    }
    else if ((HI_DRV_VIDEO_FRAME_TYPE_SLF == pstWinHdrInfo->enSrcFrameType) && (HI_PQ_DISP_TYPE_HDR10 == pstWinHdrInfo->enDispType))
    {
        HI_WARN_PQ("PQ_HAL_GetHDRCfg : Error __LINE__ == %d\n", __LINE__);
        sg_enHDRMode = HI_PQ_HDR_MODE_SLF_TO_HDR10;
        s32Ret       = pq_hal_GetSLFtoHDR10Cfg(pstWinHdrInfo->enInCS, pstWinHdrInfo->enOutCS, pstPqHdrCfg);
    }
    else if ((HI_DRV_VIDEO_FRAME_TYPE_SDR == pstWinHdrInfo->enSrcFrameType) && (HI_PQ_DISP_TYPE_HDR10 == pstWinHdrInfo->enDispType))
    {
        sg_enHDRMode = HI_PQ_HDR_MODE_SDR_TO_HDR10;
        s32Ret       = pq_hal_GetSDRtoHDR10Cfg(pstWinHdrInfo->enInCS, pstWinHdrInfo->enOutCS, pstPqHdrCfg);
    }
    else if ((HI_DRV_VIDEO_FRAME_TYPE_SDR == pstWinHdrInfo->enSrcFrameType) && (HI_PQ_DISP_TYPE_NORMAL == pstWinHdrInfo->enDispType))
    {
        sg_enHDRMode = HI_PQ_HDR_MODE_SDR_TO_SDR;
        s32Ret       = pq_hal_GetSDRtoSDRCfg(pstWinHdrInfo->enInCS, pstWinHdrInfo->enOutCS, pstPqHdrCfg);
    }
    else if ((HI_DRV_VIDEO_FRAME_TYPE_SDR == pstWinHdrInfo->enSrcFrameType) && (HI_PQ_DISP_TYPE_HLG == pstWinHdrInfo->enDispType))
    {
        sg_enHDRMode = HI_PQ_HDR_MODE_SDR_TO_HLG;
        s32Ret       = pq_hal_GetSDRtoHLGCfg(pstWinHdrInfo->enInCS, pstWinHdrInfo->enOutCS, pstPqHdrCfg);
    }

    sg_u32TMScaleCoef = pstPqHdrCfg->stTMAP.u16ScaleCoefTM;

    return s32Ret;
}

static HI_VOID pq_hal_SetHDRPqParamDefault(HI_VOID)
{
    if (HI_NULL == sg_pstHalHdrPqParam)
    {
        return;
    }

    return ;
}

HI_S32 PQ_HAL_InitHDR(PQ_PARAM_S *pstPqParam, HI_BOOL bDefault)
{
    HI_U32 u32HdrTmapBinCheckSum = 0;
    HI_U32 i = 0;

    sg_pstHalHdrPqParam = pstPqParam;

    PQ_CHECK_NULL_PTR(sg_pstHalHdrPqParam);

    for (i = 0; i < 64; i++)
    {
        u32HdrTmapBinCheckSum += sg_pstHalHdrPqParam->stPQCoef.stHdrTmCoef.au32TMLut[i];
    }

    memcpy(sg_stHdrTmapUsePara.au32TMLut,   au32TMLut_HDR10toSDR_Vivid, PQ_TMAP_LUT_SIZE * sizeof(sg_stHdrTmapUsePara.au32TMLut[0]));
    memcpy(sg_stHdrTmapUsePara.au32TM_B100, au32TMLut_HDR10toSDR_b100,  PQ_TMAP_LUT_SIZE * sizeof(sg_stHdrTmapUsePara.au32TM_B100[0]));
    memcpy(sg_stHdrTmapUsePara.au32TM_B0,   au32TMLut_HDR10toSDR_b0,    PQ_TMAP_LUT_SIZE * sizeof(sg_stHdrTmapUsePara.au32TM_B0[0]));
    memcpy(sg_stHdrTmapUsePara.au32TM_D100, au32TMLut_HDR10toSDR_d100,  PQ_TMAP_LUT_SIZE * sizeof(sg_stHdrTmapUsePara.au32TM_D100[0]));
    memcpy(sg_stHdrTmapUsePara.au32TM_D0,   au32TMLut_HDR10toSDR_d0,    PQ_TMAP_LUT_SIZE * sizeof(sg_stHdrTmapUsePara.au32TM_D0[0]));
    memcpy(sg_stHdrTmapUsePara.au32TM_BP,   au32TMLut_HDR10toSDR_BP,    PQ_TMAP_LUT_SIZE * sizeof(sg_stHdrTmapUsePara.au32TM_BP[0]));
    memcpy(sg_stHdrTmapUsePara.au32TM_DP,   au32TMLut_HDR10toSDR_DP,    PQ_TMAP_LUT_SIZE * sizeof(sg_stHdrTmapUsePara.au32TM_DP[0]));

    memcpy(&(sg_pstHalHdrPqParam->stPQCoef.stHdrTmCoef), &sg_stHdrTmapUsePara, sizeof(sg_stHdrTmapUsePara));

    sg_u32HdrParamSource = 0;

    if (HI_TRUE != bDefault)
    {
        if (u32HdrTmapBinCheckSum > 0)
        {
            memcpy(&sg_stHdrTmapUsePara, &(sg_pstHalHdrPqParam->stPQCoef.stHdrTmCoef), sizeof(sg_stHdrTmapUsePara));
            sg_u32HdrParamSource = 1;
        }
    }

    return HI_SUCCESS;
}

HI_S32 PQ_HAL_SetHDRTmLut(HI_PQ_HDR_TM_LUT_S *pstTMSetLut)
{
    return HI_SUCCESS;
}

HI_S32 PQ_HAL_GetHDRTmLut(HI_PQ_HDR_TM_LUT_S *pstTMSetLut)
{
    return HI_SUCCESS;
}

HI_S32 PQ_HAL_SetHDRDefaultCfg(HI_BOOL bDefault)
{
    pq_hal_SetHDRPqParamDefault();

    return HI_SUCCESS;
}

HI_S32 PQ_HAL_SetHDRTmXpos(HI_U8 *pstTMSetXpos)
{
    PQ_CHECK_NULL_PTR(pstTMSetXpos);

    memcpy(g_u32TMLutXStep, pstTMSetXpos, sizeof(g_u32TMLutXStep));
    memcpy(g_u32TMLutXPos, pstTMSetXpos + 8 * sizeof(HI_U32),  sizeof(g_u32TMLutXPos));
    memcpy(g_u32TMLutXNum, pstTMSetXpos + 16 * sizeof(HI_U32), sizeof(g_u32TMLutXNum));

    return HI_SUCCESS;
}

HI_S32 PQ_HAL_GetHDRTmXpos(HI_U8 *pstTMSetXpos)
{
    PQ_CHECK_NULL_PTR(pstTMSetXpos);
    PQ_CHECK_NULL_PTR(g_u32TMLutXStep);
    PQ_CHECK_NULL_PTR(g_u32TMLutXPos);
    PQ_CHECK_NULL_PTR(g_u32TMLutXNum);

    memcpy((HI_U32 *)pstTMSetXpos, g_u32TMLutXStep, sizeof(g_u32TMLutXStep));
    memcpy((HI_U32 *)(pstTMSetXpos + 8 * sizeof(HI_U32)),  g_u32TMLutXPos, sizeof(g_u32TMLutXPos));
    memcpy((HI_U32 *)(pstTMSetXpos + 16 * sizeof(HI_U32)), g_u32TMLutXNum, sizeof(g_u32TMLutXNum));

    return HI_SUCCESS;
}

HI_S32 PQ_HAL_GetHDRSrcLum(HI_PQ_HDR_SRC_LUM_S *pstGetSrclum)
{
    PQ_CHECK_NULL_PTR(pstGetSrclum);

    pstGetSrclum->u32MinLum = sg_u32SrcMinPQ;
    pstGetSrclum->u32MaxLum = sg_u32SrcMaxPQ;

    return HI_SUCCESS;
}

HI_S32 PQ_HAL_SetHDRParaMode(HI_PQ_HDR_PARA_MODE_S *pstSetParaMode)
{
    PQ_CHECK_NULL_PTR(pstSetParaMode);

    sg_u32HdrTmMode = pstSetParaMode->u32HdrTmMode;
    sg_u32HdrSmMode = pstSetParaMode->u32HdrSmMode;

    return HI_SUCCESS;
}

HI_S32 PQ_HAL_GetHDRParaMode(HI_PQ_HDR_PARA_MODE_S *pstGetParaMode)
{
    PQ_CHECK_NULL_PTR(pstGetParaMode);

    pstGetParaMode->u32HdrTmMode = sg_u32HdrTmMode;
    pstGetParaMode->u32HdrSmMode = sg_u32HdrSmMode;

    return HI_SUCCESS;
}

HI_S32 PQ_HAL_SetHDRSoftPara(HI_PQ_HDR_SOFT_PARA_S *pstSetSoftPara)
{
    PQ_CHECK_NULL_PTR(pstSetSoftPara);

    sg_u32TMScaleCoef   = pstSetSoftPara->u32TMScaleCoef;
    sg_u32SrcAvgLum     = pstSetSoftPara->u32SrcAvgLum;
    sg_u32TargMinLum    = pstSetSoftPara->u32TargMinLum;
    sg_u32TargAvgLum    = pstSetSoftPara->u32TargAvgLum;
    sg_u32TargMaxLum    = pstSetSoftPara->u32TargMaxLum;
    sg_u32UhdMaxLumDefault = pstSetSoftPara->u32UhdMaxLumDefault;
    sg_u32FhdMaxLumDefault = pstSetSoftPara->u32FhdMaxLumDefault;
    sg_u32Contrast = pstSetSoftPara->u32Contrast;
    sg_u32HdrLwAvg = pstSetSoftPara->u32HdrLwAvg;

    return HI_SUCCESS;
}

HI_S32 PQ_HAL_GetHDRSoftPara(HI_PQ_HDR_SOFT_PARA_S *pstGetSoftPara)
{
    PQ_CHECK_NULL_PTR(pstGetSoftPara);

    pstGetSoftPara->u32TMScaleCoef = sg_u32TMScaleCoef;
    pstGetSoftPara->u32SrcAvgLum   = sg_u32SrcAvgLum;
    pstGetSoftPara->u32TargMinLum  = sg_u32TargMinLum;
    pstGetSoftPara->u32TargAvgLum  = sg_u32TargAvgLum;
    pstGetSoftPara->u32TargMaxLum  = sg_u32TargMaxLum;
    pstGetSoftPara->u32Contrast    = sg_u32Contrast;
    pstGetSoftPara->u32HdrLwAvg    = sg_u32HdrLwAvg;
    pstGetSoftPara->u32UhdMaxLumDefault = sg_u32UhdMaxLumDefault;
    pstGetSoftPara->u32FhdMaxLumDefault = sg_u32FhdMaxLumDefault;

    return HI_SUCCESS;
}

HI_S32 PQ_HAL_SetHDRToneMap(HI_U8 *pstHDRToneMap)
{
    HI_U32 pTM_ylut[64] = {0};
    HI_U32 pTM_Map[64] = {0};
    HI_U32 u32TmpNum = 0;
    HI_U32 u32TmpPos = 0;
    HI_U32 u32NumCur = 0 ;
    HI_U32 u32PanelMaxLum = 0;
    HI_U32 i = 0, k = 0;
    HI_U32 u32TMbitOut = 0;
    HI_U64 u64Data = 0;

    PQ_CHECK_NULL_PTR(pstHDRToneMap);

    memcpy(pTM_ylut,  pstHDRToneMap + 32 * sizeof(HI_U32), sizeof(g_u32TMLut_debug));
    u32PanelMaxLum = pTM_ylut[63];

    if (u32PanelMaxLum == 0)
    {
        HI_ERR_PQ("Valid Parameter! Please adjust the curve!");

        return HI_SUCCESS;
    }

    memcpy(g_u32TMLutXStep, pstHDRToneMap, sizeof(g_u32TMLutXStep));
    memcpy(g_u32TMLutXNumP, pstHDRToneMap + 8 * sizeof(HI_U32),  sizeof(g_u32TMLutXNumP));
    memcpy(g_u32TMLutXNum,  pstHDRToneMap + 16 * sizeof(HI_U32), sizeof(g_u32TMLutXNum));
    memcpy(g_u32TMLutXPos,  pstHDRToneMap + 24 * sizeof(HI_U32), sizeof(g_u32TMLutXPos));

    u32TMbitOut = sg_u32TMScaleCoef;

    if ((HI_U64)u32PanelMaxLum == 0)
    {
        HI_ERR_PQ("Valid Parameter u32PanelMaxLum! Please adjust the curve!");
        return HI_FAILURE;
    }

    u64Data     = div64_s64((HI_U64)pTM_ylut[0] << 31, (HI_U64)u32PanelMaxLum);

    if ( u32TMbitOut >= 11 )
    {
        pTM_Map[i] = (HI_U32) div64_s64((u64Data << (u32TMbitOut - 11)), 1) ;
    }
    else
    {
        pTM_Map[i] =  (HI_U32) div64_s64((u64Data >> ( 11 - u32TMbitOut)), 1) ;
    }

    for ( i = 1 ; i < 64 ; i++)
    {
        u32TmpNum = i ;

        if ( u32TmpNum <= g_u32TMLutXNum[0] )
        {
            u32TmpPos = (1 << g_u32TMLutXStep[0]) * u32TmpNum + 1 ;
        }
        else
        {
            for (k = 1; k < 8 ; k++)
            {
                if ( u32TmpNum <= g_u32TMLutXNum[k] )
                {
                    u32NumCur = u32TmpNum - g_u32TMLutXNum[k - 1] ;
                    u32TmpPos = g_u32TMLutXPos[k - 1]  + (1 << g_u32TMLutXStep[k]) * u32NumCur  + 1;
                    break;
                }
            }
        }

        u32TmpPos = HDR_MIN(u32TmpPos, 1048575) ;
        u64Data = div64_s64((HI_U64)pTM_ylut[i] << 31, (HI_U64)u32PanelMaxLum) ;

        if ((HI_U64)u32TmpPos == 0)
        {
            HI_ERR_PQ("Valid Parameter u32TmpPos! Please adjust the curve!");
            return HI_FAILURE;
        }

        if ( u32TMbitOut >= 11 )
        {
            pTM_Map[i] = (HI_U32) div64_s64((u64Data << (u32TMbitOut - 11)), (HI_U64)u32TmpPos) ;
        }
        else
        {
            pTM_Map[i] =  (HI_U32) div64_s64((u64Data >> ( 11 - u32TMbitOut)), (HI_U64)u32TmpPos) ;
        }

    }

    memcpy(g_au32TM_PQTool,  pTM_Map, sizeof(pTM_Map));
    return HI_SUCCESS;
}

HI_S32 PQ_HAL_GetHDRToneMap(HI_U8 *pstHDRToneMap)
{
    HI_U32 pTM_ylut[64] = {0};
    HI_U32 pTM_Map[64] = {0};
    HI_U32 u32TmpNum = 0;
    HI_U32 u32TmpPos = 0;
    HI_U32 u32NumCur = 0 ;
    HI_U32 u32PanelMaxLum = 0;
    HI_U32 i = 0, k = 0;
    HI_U32 u32TMbitOut = 0;
    HI_U64 u64ytmp = 0;

    PQ_CHECK_NULL_PTR(pstHDRToneMap);

    g_u32TMLutXNumP[0] = g_u32TMLutXNum[0];

    for (i = 1; i < 8; i++)
    {
        g_u32TMLutXNumP[i] = g_u32TMLutXNum[i] - g_u32TMLutXNum[i - 1];
    }

    memcpy((HI_U32 *)pstHDRToneMap, g_u32TMLutXStep, sizeof(g_u32TMLutXStep));
    memcpy((HI_U32 *)(pstHDRToneMap + 8 * sizeof(HI_U32)),  g_u32TMLutXNumP, sizeof(g_u32TMLutXNumP));
    memcpy((HI_U32 *)(pstHDRToneMap + 16 * sizeof(HI_U32)), g_u32TMLutXNum , sizeof(g_u32TMLutXNum));
    memcpy((HI_U32 *)(pstHDRToneMap + 24 * sizeof(HI_U32)), g_u32TMLutXPos , sizeof(g_u32TMLutXPos));
    memcpy(pTM_Map, g_au32TM_PQTool, sizeof(pTM_Map));

    u32TMbitOut = sg_u32TMScaleCoef;

    u32PanelMaxLum = sg_u32TargMaxLum;
    u32PanelMaxLum = div64_s64(u32PanelMaxLum, 10000) ;

    pTM_ylut[0] = (HI_U32)((u64ytmp * u32PanelMaxLum) >> 31);

    if ( u32TMbitOut >= 11 )
    {
        u64ytmp = ((HI_U64)pTM_Map[0]) >> (u32TMbitOut - 11);
    }
    else
    {
        u64ytmp = ((HI_U64)pTM_Map[0]) << (u32TMbitOut - 11);
    }

    for ( i = 1 ; i < 64 ; i++)
    {
        u32TmpNum = i ;

        if ( u32TmpNum <= g_u32TMLutXNum[0] )
        {
            u32TmpPos = (1 << g_u32TMLutXStep[0]) * u32TmpNum + 1 ;
        }
        else
        {
            for (k = 1; k < 8 ; k++)
            {
                if ( u32TmpNum <= g_u32TMLutXNum[k] )
                {
                    u32NumCur = u32TmpNum - g_u32TMLutXNum[k - 1] ;
                    u32TmpPos = g_u32TMLutXPos[k - 1]  + (1 << g_u32TMLutXStep[k]) * u32NumCur  + 1;
                    break;
                }
            }
        }

        u32TmpPos = HDR_MIN(u32TmpPos, 1048575) ;

        if ( u32TMbitOut >= 11)
        {
            u64ytmp = ((HI_U64)pTM_Map[i] * u32TmpPos) >> (u32TMbitOut - 11);
        }
        else
        {
            u64ytmp = ((HI_U64)pTM_Map[i] * u32TmpPos) << (u32TMbitOut - 11);
        }

        pTM_ylut[i] = (HI_U32)((u64ytmp * u32PanelMaxLum) >> 31);
    }

    memcpy((HI_U32 *)(pstHDRToneMap + 32 * sizeof(HI_U32)), pTM_ylut, sizeof(pTM_ylut));

    return HI_SUCCESS;
}

HI_S32 PQ_HAL_SetHDRSatMap(HI_U8 *pstHDRSatMap)
{
    PQ_CHECK_NULL_PTR(pstHDRSatMap);

    memcpy(g_u32SMLutXStep, pstHDRSatMap, sizeof(g_u32SMLutXStep));
    memcpy(g_u32SMLutXNumP, pstHDRSatMap + 8 * sizeof(HI_U32),  sizeof(g_u32SMLutXNumP));
    memcpy(g_u32SMLutXNum,  pstHDRSatMap + 16 * sizeof(HI_U32), sizeof(g_u32SMLutXNum));
    memcpy(g_u32SMLutXPos,  pstHDRSatMap + 24 * sizeof(HI_U32), sizeof(g_u32SMLutXPos));
    memcpy(g_u32SMLut_debug, pstHDRSatMap + 32 * sizeof(HI_U32), sizeof(g_u32SMLut_debug));

    return HI_SUCCESS;
}

HI_S32 PQ_HAL_GetHDRSatMap(HI_U8 *pstHDRSatMap)
{
    PQ_CHECK_NULL_PTR(pstHDRSatMap);

    memcpy((HI_U32 *)pstHDRSatMap, g_u32SMLutXStep, sizeof(g_u32SMLutXStep));
    memcpy((HI_U32 *)(pstHDRSatMap + 8 * sizeof(HI_U32)),  g_u32SMLutXNumP,  sizeof(g_u32SMLutXNumP));
    memcpy((HI_U32 *)(pstHDRSatMap + 16 * sizeof(HI_U32)), g_u32SMLutXNum ,  sizeof(g_u32SMLutXNum));
    memcpy((HI_U32 *)(pstHDRSatMap + 24 * sizeof(HI_U32)), g_u32SMLutXPos ,  sizeof(g_u32SMLutXPos));
    memcpy((HI_U32 *)(pstHDRSatMap + 32 * sizeof(HI_U32)), g_u32SMLut_debug, sizeof(g_u32SMLut_debug));

    return HI_SUCCESS;
}

HI_S32 PQ_HAL_GetHDRTYMap(HI_U8 *pstHDRTYMap)
{
    PQ_CHECK_NULL_PTR(pstHDRTYMap);

    memcpy((HI_U32 *)pstHDRTYMap, g_au32TM_PQTool, sizeof(g_au32TM_PQTool));

    return HI_SUCCESS;
}

HI_S32 PQ_HAL_SetHDRTYMap(HI_U8 *pstHDRTYMap)
{
    PQ_CHECK_NULL_PTR(pstHDRTYMap);

    memcpy(g_au32TM_PQTool, (HI_U32 *)pstHDRTYMap, sizeof(g_au32TM_PQTool));
    memcpy(sg_pstHalHdrPqParam->stPQCoef.stHdrTmCoef.au32TMLut, (HI_U32 *)pstHDRTYMap, sizeof(g_au32TM_PQTool));

    return HI_SUCCESS;
}

HI_S32  HiPP_HDR_CalcXPos(HI_U32 *pTM_xlut , HI_PQ_HDR_CFG *pstPqHdrCfg)
{
    HI_U32 u32TmpNum = 0;
    HI_U32 u32TmpPos = 0;
    HI_U32 u32NumCur = 0 ;
    HI_U32 i = 0, k = 0;

    PQ_CHECK_NULL_PTR(g_u32TMLutXStep);
    PQ_CHECK_NULL_PTR(g_u32TMLutXPos);
    PQ_CHECK_NULL_PTR(g_u32TMLutXNum);

    memcpy(pstPqHdrCfg->stTMAP.au32StepTM, g_u32TMLutXStep, sizeof(g_u32TMLutXStep));
    memcpy(pstPqHdrCfg->stTMAP.au32PosTM,  g_u32TMLutXPos,  sizeof(g_u32TMLutXStep));
    memcpy(pstPqHdrCfg->stTMAP.au32NumTM,  g_u32TMLutXNum,  sizeof(g_u32TMLutXStep));

    pTM_xlut[0] = 1 ;

    for ( i = 1 ; i < 64 ; i++)
    {
        u32TmpNum = i ;

        if ( u32TmpNum <= g_u32TMLutXStep[0] )
        {
            u32TmpPos = (1 << g_u32TMLutXStep[0]) * u32TmpNum + 1 ;
        }
        else
        {
            for (k = 1; k < 8 ; k++)
            {
                if ( u32TmpNum <= g_u32TMLutXNum[k] )
                {
                    u32NumCur = u32TmpNum - g_u32TMLutXNum[k - 1] ;
                    u32TmpPos = g_u32TMLutXPos[k - 1]  + (1 << g_u32TMLutXStep[k]) * u32NumCur  + 1;
                    break;
                }
            }
        }

        u32TmpPos = HDR_MIN(u32TmpPos, 2097151) ;
        pTM_xlut[i] = u32TmpPos ;
    }

    return HI_SUCCESS;
}

HI_S32 HiPP_HDR_InitToneMappingParam(HDR_TM_PARAM_S *pstHDRParam , DM_INFO_S *pstDminfo)
{
    PQ_CHECK_NULL_PTR(pstHDRParam);
    PQ_CHECK_NULL_PTR(pstDminfo);

    //Metadata vdec传过来,u32SrcMinPQ,u32SrcMaxPQ
    pstHDRParam->u32SrcMinLum = pstDminfo->u32SrcMinPQ;    // Src Min Luminance Value : nits        x1 = 0.005*10000;     //metadate
    pstHDRParam->u32SrcMaxLum = pstDminfo->u32SrcMaxPQ;;   // Src Max Luminance Value : nits    x3 = 1200*10000;           //metadate
    sg_u32SrcMinPQ = pstDminfo->u32SrcMinPQ;
    sg_u32SrcMaxPQ = pstDminfo->u32SrcMaxPQ;

    //下面6个参数需要xml输入
    pstHDRParam->u32SrcAvgLum   = sg_u32SrcAvgLum; //150000;          // Src Avg Luminance Value : nits     x2 = 15*10000;
    pstHDRParam->u32TargMinLum  = sg_u32TargMinLum;       //1000;          // Target min Luminance Value : nits  y1 = 0.1*10000;
    pstHDRParam->u32TargAvgLum  = sg_u32TargAvgLum;      //2000000 ;       // Target Avg Luminance Value : nits   y2 = 200*10000;
    pstHDRParam->u32TargMaxLum  = sg_u32TargMaxLum;      //3000000;      // Target Max Luminance Value : nits     y3 = 300*10000;
    pstHDRParam->u32Contrast    = sg_u32Contrast;        //320;           //调节对比度                               n = 1.25*256;
    pstHDRParam->u32LwAvg       = sg_u32HdrLwAvg;        //300  最主要的调节参数 ;  //TM_EXP  源均值亮度

    return HI_SUCCESS;
}

HI_S32 HiPP_HDR_CalcTMExpParaInte(HI_U32 u32LwAvg , HDR_TMExpPARAM_S *pstTMExpPara )
{
    HI_U32 u32QBbitX        = 24 ;
    HI_U32 u32QBbitY        = 30 ;
    HI_U32 u32QBbitSclCoef  = 20 ;
    HI_U32 u32Acoef         = 10000;
    HI_U32 u32Log2exp       = 1512775  ;  //log2(e)*2^20

    pstTMExpPara->u32QBbitX = u32QBbitX ;
    pstTMExpPara->u32QBbitY = u32QBbitY ;
    pstTMExpPara->u32LwAvg  = u32LwAvg ;

    pstTMExpPara->u32Acoef          = u32Acoef ;
    pstTMExpPara->u32Log2exp        = u32Log2exp ;
    pstTMExpPara->u32QBbitSclCoef   = u32QBbitSclCoef ;

    return HI_SUCCESS;
}

HI_U64 HiPP_HDR_FixIntegPower2( HI_U64 u64Data , HI_U32 u32QBbitSclCoef ,  HI_U32  u32QBbitX )
{
    HI_U32  u32C1Power2Frac  = 1482910 ;   //2^(1/2)*2^20
    HI_U32  u32C2Power2Frac  = 1246974 ;
    HI_U32  u32C3Power2Frac  = 1143480 ;
    HI_U32  u32C4Power2Frac  = 1095000 ;
    HI_U32  u32C5Power2Frac  = 1071537 ;
    HI_U32  u32C6Power2Frac  = 1059994 ;
    HI_U32  u32C7Power2Frac  = 1054270 ;
    HI_U32  u32C8Power2Frac  = 1051419 ;
    HI_U32  u32C9Power2Frac  = 1049997 ;
    HI_U32  u32C10Power2Frac = 1049286  ;
    HI_U32  u32C11Power2Frac = 1048931  ;
    HI_U32  u32C12Power2Frac = 1048753  ;
    HI_U32  u32C13Power2Frac = 1048665  ;
    HI_U32  u32C14Power2Frac = 1048620  ;
    HI_U32  u32C15Power2Frac = 1048598  ;

    HI_U32 Coeaf2poly[15]           = {0} ;
    HI_U32 au32CoefPower2Frac[15]   = {0};
    HI_U64 u64MaxVal                =  0x7FFFFFFFFFFFFFFF  ;

    HI_U32 i = 0;
    HI_U32 u32TempData , u32Data ;
    HI_U64 u64Coeaf2polyInteg ;
    HI_U32 icount = 0 ;
    HI_U64 u64Val = 0 ;

    au32CoefPower2Frac[0]  = u32C1Power2Frac;
    au32CoefPower2Frac[1]  = u32C2Power2Frac ;
    au32CoefPower2Frac[2]  = u32C3Power2Frac ;
    au32CoefPower2Frac[3]  = u32C4Power2Frac ;
    au32CoefPower2Frac[4]  = u32C5Power2Frac ;
    au32CoefPower2Frac[5]  = u32C6Power2Frac ;
    au32CoefPower2Frac[6]  = u32C7Power2Frac ;
    au32CoefPower2Frac[7]  = u32C8Power2Frac ;
    au32CoefPower2Frac[8]  = u32C9Power2Frac ;
    au32CoefPower2Frac[9]  = u32C10Power2Frac;

    au32CoefPower2Frac[10] = u32C11Power2Frac;
    au32CoefPower2Frac[11] = u32C12Power2Frac;
    au32CoefPower2Frac[12] = u32C13Power2Frac;
    au32CoefPower2Frac[13] = u32C14Power2Frac;
    au32CoefPower2Frac[14] = u32C15Power2Frac;

    u32Data             =  (u64Data >> (u32QBbitSclCoef + u32QBbitX )) ;
    u64Coeaf2polyInteg  = u32Data & 0xFFFFFFFF ;
    u32Data             = (HI_U32)((u64Data >> 13) & 0x7FFFFFFF) ; // 1 = 2^31

    for (i = 0; i < 15; i++)
    {
        u32TempData     = u32Data & (1 << (30 - i)) ;
        Coeaf2poly[i]   = u32TempData >> (30 - i) ;
    }

    u64Data = 1 ;
    icount  = 0 ;

    for (i = 0; i < 15; i++)
    {
        if ( Coeaf2poly[i] == 1  )
        {
            if ( icount == 0 )
            {
                u64Data = u64Data * au32CoefPower2Frac[i] ;
            }
            else
            {
                u64Data = u64Data * au32CoefPower2Frac[i] ;
                u64Data = u64Data >> 20 ;
            }

            icount = icount + 1 ;
        }
    }

    if ( u64Coeaf2polyInteg <= 42 )
    {
        u64Coeaf2polyInteg = ((HI_U64)1) << (u64Coeaf2polyInteg ) ;
        u64Data =  u64Data * u64Coeaf2polyInteg ;
        u64Val = u64Data ;
    }
    else
    {
        u64Val = u64MaxVal ;
    }

    return u64Val ;

}

HI_U32 HiPP_HDR_CalcTMExpInte(HDR_TMExpPARAM_S *pstTMExpPara , HI_U32 u32XPos)
{
    HI_U64 u64Data ;
    HI_U32 u32QBbitX  ;
    HI_U32 u32QBbitY  ;
    HI_U32 u32Log2exp  ;
    HI_U32 u32LwAvg ;
    HI_U32 u32QBbitSclCoef  ;
    HI_U64 u64Power2x = 0 ;
    HI_U64 u64ValT ;
    HI_U32 u32ExpVal = 0 ;

    u32QBbitX       = pstTMExpPara->u32QBbitX ;
    u32QBbitY       = pstTMExpPara->u32QBbitY ;
    u32QBbitSclCoef = pstTMExpPara->u32QBbitSclCoef ;
    u32Log2exp      = pstTMExpPara->u32Log2exp ;
    u32LwAvg        = pstTMExpPara->u32LwAvg ;

    u64Data     = (HI_U64)u32XPos ;

    if ((HI_U64)u32LwAvg == 0)
    {
        HI_ERR_PQ("Valid Parameter u32LwAvg! Please adjust the curve!");
        return HI_FAILURE;
    }

    u64Data     = div64_s64((HI_U64)((u64Data << (u32QBbitX - 20)) * 10000 * u32Log2exp), (HI_U64)u32LwAvg) ;
    u64Power2x  = HiPP_HDR_FixIntegPower2( u64Data , u32QBbitSclCoef , u32QBbitX )  ;

    if (u64Power2x == 0)
    {
        HI_ERR_PQ("Valid Parameter u64Power2x! Please adjust the curve!");
        return HI_FAILURE;
    }

    u64ValT     = div64_s64((((HI_U64)1) << (u32QBbitSclCoef + u32QBbitY)), u64Power2x);

    if (  u64ValT < ((HI_U64)1 << u32QBbitY) )
    {
        u32ExpVal = (HI_U32)u64ValT ;
    }
    else
    {
        u32ExpVal = (1 << u32QBbitY) ;
    }

    u32ExpVal =  (1 << u32QBbitY) - u32ExpVal ;

    return u32ExpVal ;
}

/*--------------------------------------------------------------------------------*
Function                :  HI_U32 HiPP_HDR_CreateToneMappingApi(HI_U32 *paTMYLut , HI_U32 *paSMYLut ,DM_INFO_S *pstDminfo)
Description             :    软算法获取HDR LUT 曲线
Calls                   :
Data Accessed       :
Data Updated        :
Input                   :   pstHdrInfo.CNcomment: HDR10信息CNend;
Output              :   NA
Return                  :   HI_SUCCESS     success.  CNcomment:成功 CNend
Others                  :   NA
*--------------------------------------------------------------------------------*/
HI_S32 HiPP_HDR_HDR10toSDRTMApi(HI_PQ_HDR_CFG *pstPqHdrCfg, DM_INFO_S *pstDminfo)
{
    HI_U32 au32TMXLut[64] = {0} ;
    HI_U32 au32TMpLut[64] = {0} ;
    HDR_TM_PARAM_S stHDRParam ;
    HDR_TMExpPARAM_S stTMExpPara ;
    HI_U32 u32XPos ;
    HI_U32 u32SrcMaxLum = 0 ;
    HI_U32 u32PanelMaxLum = 0 ;
    HI_U32 u32MaxLumXPos , u32MaxExpLum;
    HI_U32 u32ValTemp ;
    HI_U64 u64Data ;
    HI_S32 s32ShiftBit = 0 ;
    HI_S32 i = 0;
    HI_VDP_PQ_INFO_S  stVdpInfo = {0};

    HiPP_HDR_CalcXPos(au32TMXLut, pstPqHdrCfg ) ;

    HiPP_HDR_InitToneMappingParam(&stHDRParam , pstDminfo);

    HiPP_HDR_CalcTMExpParaInte (stHDRParam.u32LwAvg , &stTMExpPara ) ;

    u32PanelMaxLum  = stHDRParam.u32TargMaxLum ;
    u32SrcMaxLum    = stHDRParam.u32SrcMaxLum ;

    if ( u32SrcMaxLum > 5000000 )
    {
        u64Data = (HI_U64)u32SrcMaxLum ;
        u64Data =  div64_s64((u64Data << 21), 10000 * 10000);
    }
    else
    {
        //根据宽高
        if ((stVdpInfo.u32Width >= 3840) && (stVdpInfo.u32Height >= 2160))
        {
            u64Data = sg_u32UhdMaxLumDefault ;
        }
        else
        {
            u64Data = sg_u32FhdMaxLumDefault ;
        }

        u64Data = div64_s64((u64Data << 21), 10000 * 10000) ;
    }

    u32MaxLumXPos = (HI_U32)u64Data ;
    u32MaxExpLum  =  HiPP_HDR_CalcTMExpInte( &stTMExpPara ,  u32MaxLumXPos) ;

    if (u32MaxExpLum == 0)
    {
        u32MaxExpLum = 1;
        HI_INFO_PQ("u32MaxExpLum:%d\n", u32MaxExpLum);
    }

    for (i = 0; i < 64 ; i++)
    {

        u32XPos         = au32TMXLut[i] ;
        u32ValTemp      = HiPP_HDR_CalcTMExpInte( &stTMExpPara ,  u32XPos) ;
        au32TMpLut[i]   = div64_s64(((HI_U64)u32ValTemp << stTMExpPara.u32QBbitY) , (HI_U64)u32MaxExpLum);
    }

    /*读取寄存器的值 OutBit */
    s32ShiftBit = sg_u32TMScaleCoef - (stTMExpPara.u32QBbitY - 21) ;

    for (i = 0; i < 64 ; i++)
    {
        if (au32TMXLut[i] == 0)
        {
            HI_ERR_PQ("Valid Parameter au32TMXLut[i], i = %d\n", i);
            return HI_FAILURE;
        }
    }

    if ( s32ShiftBit >= 0 )
    {
        for (i = 0; i < 64 ; i++)
        {
            pstPqHdrCfg->stTMAP.pu32LUTTM[i] =  div64_u64(((HI_U64)au32TMpLut[i] << ABS(s32ShiftBit)), au32TMXLut[i]) ;
        }
    }
    else
    {
        s32ShiftBit = s32ShiftBit * (-1) ;

        for (i = 0; i < 64 ; i++)
        {
            pstPqHdrCfg->stTMAP.pu32LUTTM[i] = div64_u64(((HI_U64)au32TMpLut[i] >> ABS(s32ShiftBit)), au32TMXLut[i]) ;
        }
    }

    pstPqHdrCfg->stTMAP.pu32LUTTM[0]    = pstPqHdrCfg->stTMAP.pu32LUTTM[1]  ;
    pstPqHdrCfg->stTMAP.u16ScaleCoefTM  = sg_u32TMScaleCoef;

    return HI_SUCCESS;
}

